{"ast":null,"code":"import { InjectionToken, Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { tap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst StorageOption = {\n  LocalStorage: 0,\n  SessionStorage: 1\n};\n/**\n * @record\n */\n\nfunction NgxsStoragePluginOptions() {}\n\nif (false) {\n  /**\n   * Key for the state slice to store in the storage engine.\n   * @type {?|undefined}\n   */\n  NgxsStoragePluginOptions.prototype.key;\n  /**\n   * Storage engine to use. Deaults to localStorage but can provide\n   *\n   * sessionStorage or custom implementation of the StorageEngine interface\n   * @type {?|undefined}\n   */\n\n  NgxsStoragePluginOptions.prototype.storage;\n  /**\n   * Migration strategies.\n   * @type {?|undefined}\n   */\n\n  NgxsStoragePluginOptions.prototype.migrations;\n  /**\n   * Serailizer for the object before its pushed into the engine.\n   * @param {?} obj\n   * @return {?}\n   */\n\n  NgxsStoragePluginOptions.prototype.serialize = function (obj) {};\n  /**\n   * Deserializer for the object before its pulled out of the engine.\n   * @param {?} obj\n   * @return {?}\n   */\n\n\n  NgxsStoragePluginOptions.prototype.deserialize = function (obj) {};\n  /**\n   * Method to alter object before serialization.\n   * @param {?} obj\n   * @param {?} key\n   * @return {?}\n   */\n\n\n  NgxsStoragePluginOptions.prototype.beforeSerialize = function (obj, key) {};\n  /**\n   * Method to alter object after deserialization.\n   * @param {?} obj\n   * @param {?} key\n   * @return {?}\n   */\n\n\n  NgxsStoragePluginOptions.prototype.afterDeserialize = function (obj, key) {};\n}\n/** @type {?} */\n\n\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTION');\n/** @type {?} */\n\nconst STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');\n/**\n * @record\n */\n\nfunction StorageEngine() {}\n\nif (false) {\n  /** @type {?} */\n  StorageEngine.prototype.length;\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n\n  StorageEngine.prototype.getItem = function (key) {};\n  /**\n   * @param {?} key\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  StorageEngine.prototype.setItem = function (key, val) {};\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n\n\n  StorageEngine.prototype.removeItem = function (key) {};\n  /**\n   * @return {?}\n   */\n\n\n  StorageEngine.prototype.clear = function () {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * If the `key` option is not provided then the below constant\n * will be used as a default key\n * @type {?}\n */\n\n\nconst DEFAULT_STATE_KEY = '@@STATE';\n/**\n * This key is used to retrieve static metadatas on state classes.\n * This constant is taken from the core codebase\n * @type {?}\n */\n\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n/**\n * @param {?} key\n * @return {?}\n */\n\nfunction transformKeyOption(key) {\n  if (!Array.isArray(key)) {\n    key = [key];\n  }\n\n  return key.map(\n  /**\n  * @param {?} token\n  * @return {?}\n  */\n  token => {\n    // If it has the `NGXS_OPTIONS_META` key then it means the developer\n    // has provided state class like `key: [AuthState]`.\n    if (token.hasOwnProperty(META_OPTIONS_KEY)) {\n      // The `name` property will be an actual state name or a `StateToken`.\n      token =\n      /** @type {?} */\n      token[META_OPTIONS_KEY].name;\n    }\n\n    return token instanceof StateToken ? token.getName() :\n    /** @type {?} */\n    token;\n  });\n}\n/**\n * @param {?} options\n * @return {?}\n */\n\n\nfunction storageOptionsFactory(options) {\n  if (options !== undefined && options.key) {\n    options.key = transformKeyOption(options.key);\n  }\n\n  return Object.assign({\n    key: [DEFAULT_STATE_KEY],\n    storage: 0\n    /* LocalStorage */\n    ,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize:\n    /**\n    * @param {?} obj\n    * @return {?}\n    */\n    obj => obj,\n    afterDeserialize:\n    /**\n    * @param {?} obj\n    * @return {?}\n    */\n    obj => obj\n  }, options);\n}\n/**\n * @param {?} options\n * @param {?} platformId\n * @return {?}\n */\n\n\nfunction engineFactory(options, platformId) {\n  if (isPlatformServer(platformId)) {\n    return null;\n  }\n\n  if (options.storage === 0\n  /* LocalStorage */\n  ) {\n    return localStorage;\n  } else if (options.storage === 1\n  /* SessionStorage */\n  ) {\n    return sessionStorage;\n  }\n\n  return null;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass NgxsStoragePlugin {\n  /**\n   * @param {?} _options\n   * @param {?} _engine\n   * @param {?} _platformId\n   */\n  constructor(_options, _engine, _platformId) {\n    this._options = _options;\n    this._engine = _engine;\n    this._platformId = _platformId; // We cast to `string[]` here as we're sure that this option has been\n    // transformed by the `storageOptionsFactory` function that provided token.\n\n    this._keys =\n    /** @type {?} */\n    this._options.key; // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n\n    this._usesDefaultStateKey = this._keys.length === 1 && this._keys[0] === DEFAULT_STATE_KEY;\n  }\n  /**\n   * @param {?} state\n   * @param {?} event\n   * @param {?} next\n   * @return {?}\n   */\n\n\n  handle(state, event, next) {\n    if (isPlatformServer(this._platformId) && this._engine === null) {\n      return next(state, event);\n    }\n    /** @type {?} */\n\n\n    const matches = actionMatcher(event);\n    /** @type {?} */\n\n    const isInitAction = matches(InitState);\n    /** @type {?} */\n\n    const isUpdateAction = matches(UpdateState);\n    /** @type {?} */\n\n    const isInitOrUpdateAction = isInitAction || isUpdateAction;\n    /** @type {?} */\n\n    let hasMigration = false;\n\n    if (isInitOrUpdateAction) {\n      /** @type {?} */\n      const addedStates = isUpdateAction && event.addedStates;\n\n      for (const key of this._keys) {\n        // We're checking what states have been added by NGXS and if any of these states should be handled by\n        // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n        // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n        // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n        if (!this._usesDefaultStateKey && addedStates && !addedStates.hasOwnProperty(key)) {\n          continue;\n        }\n        /** @type {?} */\n\n\n        let storedValue = this._engine.getItem(\n        /** @type {?} */\n        key);\n\n        if (storedValue !== 'undefined' && storedValue != null) {\n          try {\n            /** @type {?} */\n            const newVal =\n            /** @type {?} */\n            this._options.deserialize(storedValue);\n\n            storedValue =\n            /** @type {?} */\n            this._options.afterDeserialize(newVal, key);\n          } catch (_a) {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              console.error(`Error ocurred while deserializing the ${key} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n            }\n\n            storedValue = {};\n          }\n\n          if (this._options.migrations) {\n            this._options.migrations.forEach(\n            /**\n            * @param {?} strategy\n            * @return {?}\n            */\n            strategy => {\n              /** @type {?} */\n              const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n              /** @type {?} */\n\n              const keyMatch = !strategy.key && this._usesDefaultStateKey || strategy.key === key;\n\n              if (versionMatch && keyMatch) {\n                storedValue = strategy.migrate(storedValue);\n                hasMigration = true;\n              }\n            });\n          }\n\n          if (!this._usesDefaultStateKey) {\n            state = setValue(state,\n            /** @type {?} */\n            key, storedValue);\n          } else {\n            // The `UpdateState` action is dispatched whenever the feature state is added.\n            // The below condition is met only when the `UpdateState` is dispatched.\n            // Let's assume that we have 2 states `counter` and `@ngxs/router-plugin` state.\n            // `CounterState` is provided on the root level when calling `NgxsModule.forRoot()`\n            // and `@ngxs/router-plugin` is provided as a feature state.\n            // The storage plugin may save the `counter` state value as `10` before.\n            // The `CounterState` may implement the `ngxsOnInit` hook and call `ctx.setState(999)`.\n            // The storage plugin will re-hydrate the whole state when the `RouterState` is registered,\n            // and the `counter` state will again equal `10` (not `999`).\n            if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n              storedValue = Object.keys(addedStates).reduce(\n              /**\n              * @param {?} accumulator\n              * @param {?} addedState\n              * @return {?}\n              */\n              (accumulator, addedState) => {\n                // The `storedValue` may equal the whole state (when the default state key is used).\n                // If `addedStates` contains only `router` then we want to merge the state only\n                // with the `router` value.\n                // Let's assume that the `storedValue` is an object:\n                // `{ counter: 10, router: {...} }`\n                // This will pick only the `router` object from the `storedValue` and `counter`\n                // state will not be re-hydrated unnecessary.\n                if (storedValue.hasOwnProperty(addedState)) {\n                  accumulator[addedState] = storedValue[addedState];\n                }\n\n                return accumulator;\n              },\n              /** @type {?} */\n              {});\n            }\n\n            state = Object.assign({}, state, storedValue);\n          }\n        }\n      }\n    }\n\n    return next(state, event).pipe(tap(\n    /**\n    * @param {?} nextState\n    * @return {?}\n    */\n    nextState => {\n      if (!isInitOrUpdateAction || isInitOrUpdateAction && hasMigration) {\n        for (const key of this._keys) {\n          /** @type {?} */\n          let val = nextState;\n\n          if (key !== DEFAULT_STATE_KEY) {\n            val = getValue(nextState,\n            /** @type {?} */\n            key);\n          }\n\n          try {\n            /** @type {?} */\n            const newVal =\n            /** @type {?} */\n            this._options.beforeSerialize(val, key);\n\n            this._engine.setItem(\n            /** @type {?} */\n            key,\n            /** @type {?} */\n            this._options.serialize(newVal));\n          } catch (error) {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                console.error(`The ${key} store value exceeds the browser storage quota: `, val);\n              } else {\n                console.error(`Error ocurred while serializing the ${key} store value, value not updated, the value obtained from the store: `, val);\n              }\n            }\n          }\n        }\n      }\n    }));\n  }\n\n}\n\nNgxsStoragePlugin.ɵfac = function NgxsStoragePlugin_Factory(t) {\n  return new (t || NgxsStoragePlugin)(ɵngcc0.ɵɵinject(NGXS_STORAGE_PLUGIN_OPTIONS), ɵngcc0.ɵɵinject(STORAGE_ENGINE), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\n\nNgxsStoragePlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NgxsStoragePlugin,\n  factory: NgxsStoragePlugin.ɵfac\n});\n/** @nocollapse */\n\nNgxsStoragePlugin.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [NGXS_STORAGE_PLUGIN_OPTIONS]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [STORAGE_ENGINE]\n  }]\n}, {\n  type: String,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxsStoragePlugin, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [STORAGE_ENGINE]\n      }]\n    }, {\n      type: String,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  NgxsStoragePlugin.prototype._keys;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxsStoragePlugin.prototype._usesDefaultStateKey;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxsStoragePlugin.prototype._options;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxsStoragePlugin.prototype._engine;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxsStoragePlugin.prototype._platformId;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\n\nclass NgxsStoragePluginModule {\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n  static forRoot(options) {\n    return {\n      ngModule: NgxsStoragePluginModule,\n      providers: [{\n        provide: NGXS_PLUGINS,\n        useClass: NgxsStoragePlugin,\n        multi: true\n      }, {\n        provide: USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: storageOptionsFactory,\n        deps: [USER_OPTIONS]\n      }, {\n        provide: STORAGE_ENGINE,\n        useFactory: engineFactory,\n        deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n      }]\n    };\n  }\n\n}\n\nNgxsStoragePluginModule.ɵfac = function NgxsStoragePluginModule_Factory(t) {\n  return new (t || NgxsStoragePluginModule)();\n};\n\nNgxsStoragePluginModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgxsStoragePluginModule\n});\nNgxsStoragePluginModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxsStoragePluginModule, [{\n    type: NgModule\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, STORAGE_ENGINE, USER_OPTIONS as ɵa, storageOptionsFactory as ɵb, engineFactory as ɵc };","map":{"version":3,"names":["InjectionToken","Injectable","Inject","PLATFORM_ID","NgModule","StateToken","actionMatcher","InitState","UpdateState","getValue","setValue","NGXS_PLUGINS","isPlatformServer","tap","ɵngcc0","StorageOption","LocalStorage","SessionStorage","NgxsStoragePluginOptions","prototype","key","storage","migrations","serialize","obj","deserialize","beforeSerialize","afterDeserialize","NGXS_STORAGE_PLUGIN_OPTIONS","STORAGE_ENGINE","StorageEngine","length","getItem","setItem","val","removeItem","clear","DEFAULT_STATE_KEY","META_OPTIONS_KEY","transformKeyOption","Array","isArray","map","token","hasOwnProperty","name","getName","storageOptionsFactory","options","undefined","Object","assign","JSON","stringify","parse","engineFactory","platformId","localStorage","sessionStorage","NgxsStoragePlugin","constructor","_options","_engine","_platformId","_keys","_usesDefaultStateKey","handle","state","event","next","matches","isInitAction","isUpdateAction","isInitOrUpdateAction","hasMigration","addedStates","storedValue","newVal","_a","ngDevMode","console","error","forEach","strategy","versionMatch","version","versionKey","keyMatch","migrate","keys","reduce","accumulator","addedState","pipe","nextState","ɵfac","NgxsStoragePlugin_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","factory","ctorParameters","type","decorators","args","String","ɵsetClassMetadata","USER_OPTIONS","NgxsStoragePluginModule","forRoot","ngModule","providers","provide","useClass","multi","useValue","useFactory","deps","NgxsStoragePluginModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","ɵa","ɵb","ɵc"],"sources":["/home/melisagulsan/workspace/Project/product-catalog-project/node_modules/@ngxs/storage-plugin/__ivy_ngcc__/fesm2015/ngxs-storage-plugin.js"],"sourcesContent":["import { InjectionToken, Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nimport * as ɵngcc0 from '@angular/core';\nconst StorageOption = {\n    LocalStorage: 0,\n    SessionStorage: 1,\n};\n/**\n * @record\n */\nfunction NgxsStoragePluginOptions() { }\nif (false) {\n    /**\n     * Key for the state slice to store in the storage engine.\n     * @type {?|undefined}\n     */\n    NgxsStoragePluginOptions.prototype.key;\n    /**\n     * Storage engine to use. Deaults to localStorage but can provide\n     *\n     * sessionStorage or custom implementation of the StorageEngine interface\n     * @type {?|undefined}\n     */\n    NgxsStoragePluginOptions.prototype.storage;\n    /**\n     * Migration strategies.\n     * @type {?|undefined}\n     */\n    NgxsStoragePluginOptions.prototype.migrations;\n    /**\n     * Serailizer for the object before its pushed into the engine.\n     * @param {?} obj\n     * @return {?}\n     */\n    NgxsStoragePluginOptions.prototype.serialize = function (obj) { };\n    /**\n     * Deserializer for the object before its pulled out of the engine.\n     * @param {?} obj\n     * @return {?}\n     */\n    NgxsStoragePluginOptions.prototype.deserialize = function (obj) { };\n    /**\n     * Method to alter object before serialization.\n     * @param {?} obj\n     * @param {?} key\n     * @return {?}\n     */\n    NgxsStoragePluginOptions.prototype.beforeSerialize = function (obj, key) { };\n    /**\n     * Method to alter object after deserialization.\n     * @param {?} obj\n     * @param {?} key\n     * @return {?}\n     */\n    NgxsStoragePluginOptions.prototype.afterDeserialize = function (obj, key) { };\n}\n/** @type {?} */\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTION');\n/** @type {?} */\nconst STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');\n/**\n * @record\n */\nfunction StorageEngine() { }\nif (false) {\n    /** @type {?} */\n    StorageEngine.prototype.length;\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    StorageEngine.prototype.getItem = function (key) { };\n    /**\n     * @param {?} key\n     * @param {?} val\n     * @return {?}\n     */\n    StorageEngine.prototype.setItem = function (key, val) { };\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    StorageEngine.prototype.removeItem = function (key) { };\n    /**\n     * @return {?}\n     */\n    StorageEngine.prototype.clear = function () { };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * If the `key` option is not provided then the below constant\n * will be used as a default key\n * @type {?}\n */\nconst DEFAULT_STATE_KEY = '@@STATE';\n/**\n * This key is used to retrieve static metadatas on state classes.\n * This constant is taken from the core codebase\n * @type {?}\n */\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n/**\n * @param {?} key\n * @return {?}\n */\nfunction transformKeyOption(key) {\n    if (!Array.isArray(key)) {\n        key = [key];\n    }\n    return key.map((/**\n     * @param {?} token\n     * @return {?}\n     */\n    (token) => {\n        // If it has the `NGXS_OPTIONS_META` key then it means the developer\n        // has provided state class like `key: [AuthState]`.\n        if (token.hasOwnProperty(META_OPTIONS_KEY)) {\n            // The `name` property will be an actual state name or a `StateToken`.\n            token = ((/** @type {?} */ (token)))[META_OPTIONS_KEY].name;\n        }\n        return token instanceof StateToken ? token.getName() : ((/** @type {?} */ (token)));\n    }));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction storageOptionsFactory(options) {\n    if (options !== undefined && options.key) {\n        options.key = transformKeyOption(options.key);\n    }\n    return Object.assign({ key: [DEFAULT_STATE_KEY], storage: 0 /* LocalStorage */, serialize: JSON.stringify, deserialize: JSON.parse, beforeSerialize: (/**\n         * @param {?} obj\n         * @return {?}\n         */\n        obj => obj), afterDeserialize: (/**\n         * @param {?} obj\n         * @return {?}\n         */\n        obj => obj) }, options);\n}\n/**\n * @param {?} options\n * @param {?} platformId\n * @return {?}\n */\nfunction engineFactory(options, platformId) {\n    if (isPlatformServer(platformId)) {\n        return null;\n    }\n    if (options.storage === 0 /* LocalStorage */) {\n        return localStorage;\n    }\n    else if (options.storage === 1 /* SessionStorage */) {\n        return sessionStorage;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass NgxsStoragePlugin {\n    /**\n     * @param {?} _options\n     * @param {?} _engine\n     * @param {?} _platformId\n     */\n    constructor(_options, _engine, _platformId) {\n        this._options = _options;\n        this._engine = _engine;\n        this._platformId = _platformId;\n        // We cast to `string[]` here as we're sure that this option has been\n        // transformed by the `storageOptionsFactory` function that provided token.\n        this._keys = (/** @type {?} */ (this._options.key));\n        // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n        this._usesDefaultStateKey = this._keys.length === 1 && this._keys[0] === DEFAULT_STATE_KEY;\n    }\n    /**\n     * @param {?} state\n     * @param {?} event\n     * @param {?} next\n     * @return {?}\n     */\n    handle(state, event, next) {\n        if (isPlatformServer(this._platformId) && this._engine === null) {\n            return next(state, event);\n        }\n        /** @type {?} */\n        const matches = actionMatcher(event);\n        /** @type {?} */\n        const isInitAction = matches(InitState);\n        /** @type {?} */\n        const isUpdateAction = matches(UpdateState);\n        /** @type {?} */\n        const isInitOrUpdateAction = isInitAction || isUpdateAction;\n        /** @type {?} */\n        let hasMigration = false;\n        if (isInitOrUpdateAction) {\n            /** @type {?} */\n            const addedStates = isUpdateAction && event.addedStates;\n            for (const key of this._keys) {\n                // We're checking what states have been added by NGXS and if any of these states should be handled by\n                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n                // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n                if (!this._usesDefaultStateKey && addedStates && !addedStates.hasOwnProperty(key)) {\n                    continue;\n                }\n                /** @type {?} */\n                let storedValue = this._engine.getItem((/** @type {?} */ (key)));\n                if (storedValue !== 'undefined' && storedValue != null) {\n                    try {\n                        /** @type {?} */\n                        const newVal = (/** @type {?} */ (this._options.deserialize))(storedValue);\n                        storedValue = (/** @type {?} */ (this._options.afterDeserialize))(newVal, key);\n                    }\n                    catch (_a) {\n                        // Caretaker note: we have still left the `typeof` condition in order to avoid\n                        // creating a breaking change for projects that still use the View Engine.\n                        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                            console.error(`Error ocurred while deserializing the ${key} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n                        }\n                        storedValue = {};\n                    }\n                    if (this._options.migrations) {\n                        this._options.migrations.forEach((/**\n                         * @param {?} strategy\n                         * @return {?}\n                         */\n                        strategy => {\n                            /** @type {?} */\n                            const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n                            /** @type {?} */\n                            const keyMatch = (!strategy.key && this._usesDefaultStateKey) || strategy.key === key;\n                            if (versionMatch && keyMatch) {\n                                storedValue = strategy.migrate(storedValue);\n                                hasMigration = true;\n                            }\n                        }));\n                    }\n                    if (!this._usesDefaultStateKey) {\n                        state = setValue(state, (/** @type {?} */ (key)), storedValue);\n                    }\n                    else {\n                        // The `UpdateState` action is dispatched whenever the feature state is added.\n                        // The below condition is met only when the `UpdateState` is dispatched.\n                        // Let's assume that we have 2 states `counter` and `@ngxs/router-plugin` state.\n                        // `CounterState` is provided on the root level when calling `NgxsModule.forRoot()`\n                        // and `@ngxs/router-plugin` is provided as a feature state.\n                        // The storage plugin may save the `counter` state value as `10` before.\n                        // The `CounterState` may implement the `ngxsOnInit` hook and call `ctx.setState(999)`.\n                        // The storage plugin will re-hydrate the whole state when the `RouterState` is registered,\n                        // and the `counter` state will again equal `10` (not `999`).\n                        if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n                            storedValue = Object.keys(addedStates).reduce((/**\n                             * @param {?} accumulator\n                             * @param {?} addedState\n                             * @return {?}\n                             */\n                            (accumulator, addedState) => {\n                                // The `storedValue` may equal the whole state (when the default state key is used).\n                                // If `addedStates` contains only `router` then we want to merge the state only\n                                // with the `router` value.\n                                // Let's assume that the `storedValue` is an object:\n                                // `{ counter: 10, router: {...} }`\n                                // This will pick only the `router` object from the `storedValue` and `counter`\n                                // state will not be re-hydrated unnecessary.\n                                if (storedValue.hasOwnProperty(addedState)) {\n                                    accumulator[addedState] = storedValue[addedState];\n                                }\n                                return accumulator;\n                            }), (/** @type {?} */ ({})));\n                        }\n                        state = Object.assign({}, state, storedValue);\n                    }\n                }\n            }\n        }\n        return next(state, event).pipe(tap((/**\n         * @param {?} nextState\n         * @return {?}\n         */\n        nextState => {\n            if (!isInitOrUpdateAction || (isInitOrUpdateAction && hasMigration)) {\n                for (const key of this._keys) {\n                    /** @type {?} */\n                    let val = nextState;\n                    if (key !== DEFAULT_STATE_KEY) {\n                        val = getValue(nextState, (/** @type {?} */ (key)));\n                    }\n                    try {\n                        /** @type {?} */\n                        const newVal = (/** @type {?} */ (this._options.beforeSerialize))(val, key);\n                        this._engine.setItem((/** @type {?} */ (key)), (/** @type {?} */ (this._options.serialize))(newVal));\n                    }\n                    catch (error) {\n                        // Caretaker note: we have still left the `typeof` condition in order to avoid\n                        // creating a breaking change for projects that still use the View Engine.\n                        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                            if (error &&\n                                (error.name === 'QuotaExceededError' ||\n                                    error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                                console.error(`The ${key} store value exceeds the browser storage quota: `, val);\n                            }\n                            else {\n                                console.error(`Error ocurred while serializing the ${key} store value, value not updated, the value obtained from the store: `, val);\n                            }\n                        }\n                    }\n                }\n            }\n        })));\n    }\n}\nNgxsStoragePlugin.ɵfac = function NgxsStoragePlugin_Factory(t) { return new (t || NgxsStoragePlugin)(ɵngcc0.ɵɵinject(NGXS_STORAGE_PLUGIN_OPTIONS), ɵngcc0.ɵɵinject(STORAGE_ENGINE), ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nNgxsStoragePlugin.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NgxsStoragePlugin, factory: NgxsStoragePlugin.ɵfac });\n/** @nocollapse */\nNgxsStoragePlugin.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [NGXS_STORAGE_PLUGIN_OPTIONS,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [STORAGE_ENGINE,] }] },\n    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxsStoragePlugin, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [NGXS_STORAGE_PLUGIN_OPTIONS]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [STORAGE_ENGINE]\n            }] }, { type: String, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxsStoragePlugin.prototype._keys;\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxsStoragePlugin.prototype._usesDefaultStateKey;\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxsStoragePlugin.prototype._options;\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxsStoragePlugin.prototype._engine;\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxsStoragePlugin.prototype._platformId;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nclass NgxsStoragePluginModule {\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    static forRoot(options) {\n        return {\n            ngModule: NgxsStoragePluginModule,\n            providers: [\n                {\n                    provide: NGXS_PLUGINS,\n                    useClass: NgxsStoragePlugin,\n                    multi: true\n                },\n                {\n                    provide: USER_OPTIONS,\n                    useValue: options\n                },\n                {\n                    provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n                    useFactory: storageOptionsFactory,\n                    deps: [USER_OPTIONS]\n                },\n                {\n                    provide: STORAGE_ENGINE,\n                    useFactory: engineFactory,\n                    deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n                }\n            ]\n        };\n    }\n}\nNgxsStoragePluginModule.ɵfac = function NgxsStoragePluginModule_Factory(t) { return new (t || NgxsStoragePluginModule)(); };\nNgxsStoragePluginModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxsStoragePluginModule });\nNgxsStoragePluginModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxsStoragePluginModule, [{\n        type: NgModule\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, STORAGE_ENGINE, USER_OPTIONS as ɵa, storageOptionsFactory as ɵb, engineFactory as ɵc };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}