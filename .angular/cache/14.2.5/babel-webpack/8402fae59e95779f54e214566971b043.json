{"ast":null,"code":"import { NgZone, Injectable, Inject, PLATFORM_ID, defineInjectable, inject, InjectionToken, INJECTOR, ɵglobal, Optional, SkipSelf, ErrorHandler, Injector, ɵivyEnabled, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, NGXS_STATE_CONTEXT_FACTORY, NGXS_STATE_FACTORY, InitialState } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, queueScheduler } from 'rxjs';\nimport { filter, map, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, tap, observeOn, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} name\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngxs/store/internals';\n\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\n/**\n * @return {?}\n */\n\n\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\n/**\n * @param {?} current\n * @param {?} newName\n * @param {?} oldName\n * @return {?}\n */\n\n\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\n/**\n * @param {?} name\n * @return {?}\n */\n\n\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\n/**\n * @return {?}\n */\n\n\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\n/**\n * @return {?}\n */\n\n\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\n/**\n * @return {?}\n */\n\n\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\n/**\n * @param {?} name\n * @return {?}\n */\n\n\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\n/**\n * @return {?}\n */\n\n\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\n/**\n * @return {?}\n */\n\n\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\n/**\n * @return {?}\n */\n\n\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  /**\n   * @param {?} _ngZone\n   * @param {?} _platformId\n   */\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId; // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n\n    return this.runOutsideAngular(func);\n  }\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n  /**\n   * @private\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n\n    return this._ngZone.run(func);\n  }\n  /**\n   * @private\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n\n    return func();\n  }\n\n}\n\nDispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n  return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\n\nDispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ngInjectableDef = defineInjectable({\n  factory: function DispatchOutsideZoneNgxsExecutionStrategy_Factory() {\n    return new DispatchOutsideZoneNgxsExecutionStrategy(inject(NgZone), inject(PLATFORM_ID));\n  },\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DispatchOutsideZoneNgxsExecutionStrategy.prototype._ngZone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DispatchOutsideZoneNgxsExecutionStrategy.prototype._platformId;\n} // Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\n\n/**\n * @param {?} ngZone\n * @return {?}\n */\n\n\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n\n  console.warn(getZoneWarningMessage());\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\n/** @type {?} */\n\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\n/** @type {?} */\n\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\n/** @type {?} */\n\nconst META_KEY = 'NGXS_META';\n/** @type {?} */\n\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n/** @type {?} */\n\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\n\nlet NgxsConfig = /*#__PURE__*/(() => {\n  class NgxsConfig {\n    constructor() {\n      /**\n       * Defining the default state before module initialization\n       * This is convenient if we need to create a define our own set of states.\n       * @deprecated will be removed after v4\n       * (default: {})\n       */\n      this.defaultsState = {};\n      /**\n       * Defining shared selector options\n       */\n\n      this.selectorOptions = {\n        injectContainerState: true,\n        // TODO: default is true in v3, will change in v4\n        suppressErrors: true // TODO: default is true in v3, will change in v4\n\n      };\n      this.compatibility = {\n        strictContentSecurityPolicy: false\n      };\n      this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    }\n\n  }\n\n  NgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n    return new (t || NgxsConfig)();\n  };\n\n  NgxsConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxsConfig,\n    factory: NgxsConfig.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgxsConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Run in development mode. This will add additional debugging features:\n   * - Object.freeze on the state and actions to guarantee immutability\n   * (default: false)\n   *\n   * Note: this property will be accounted only in development mode when using the Ivy compiler.\n   * It makes sense to use it only during development to ensure there're no state mutations.\n   * When building for production, the Object.freeze will be tree-shaken away.\n   * @type {?}\n   */\n  NgxsConfig.prototype.developmentMode;\n  /** @type {?} */\n\n  NgxsConfig.prototype.compatibility;\n  /**\n   * Determines the execution context to perform async operations inside. An implementation can be\n   * provided to override the default behaviour where the async operations are run\n   * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\n   * These observable behaviours are from:\n   *   `\\@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\n   * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\n   * application doesn't rely on zone.js running change detection then you can switch to the\n   * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\n   * (default: null)\n   * @type {?}\n   */\n\n  NgxsConfig.prototype.executionStrategy;\n  /**\n   * Defining the default state before module initialization\n   * This is convenient if we need to create a define our own set of states.\n   * @deprecated will be removed after v4\n   * (default: {})\n   * @type {?}\n   */\n\n  NgxsConfig.prototype.defaultsState;\n  /**\n   * Defining shared selector options\n   * @type {?}\n   */\n\n  NgxsConfig.prototype.selectorOptions;\n}\n/**\n * State context provided to the actions in the state.\n * @record\n * @template T\n */\n\n\nfunction StateContext() {}\n\nif (false) {\n  /**\n   * Get the current state.\n   * @return {?}\n   */\n  StateContext.prototype.getState = function () {};\n  /**\n   * Reset the state to a new value.\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  StateContext.prototype.setState = function (val) {};\n  /**\n   * Patch the existing state with the provided value.\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  StateContext.prototype.patchState = function (val) {};\n  /**\n   * Dispatch a new action and return the dispatched observable.\n   * @param {?} actions\n   * @return {?}\n   */\n\n\n  StateContext.prototype.dispatch = function (actions) {};\n}\n/**\n * Plugin interface\n * @record\n */\n\n\nfunction NgxsPlugin() {}\n\nif (false) {\n  /**\n   * Handle the state/action before its submitted to the state handlers.\n   * @param {?} state\n   * @param {?} action\n   * @param {?} next\n   * @return {?}\n   */\n  NgxsPlugin.prototype.handle = function (state, action, next) {};\n}\n/**\n * Options that can be provided to the store.\n * @record\n * @template T\n */\n\n\nfunction StoreOptions() {}\n\nif (false) {\n  /**\n   * Name of the state. Required.\n   * @type {?}\n   */\n  StoreOptions.prototype.name;\n  /**\n   * Default values for the state. If not provided, uses empty object.\n   * @type {?|undefined}\n   */\n\n  StoreOptions.prototype.defaults;\n  /**\n   * Sub states for the given state.\n   * @type {?|undefined}\n   */\n\n  StoreOptions.prototype.children;\n}\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n * @template T\n */\n\n\nclass NgxsSimpleChange {\n  /**\n   * @param {?} previousValue\n   * @param {?} currentValue\n   * @param {?} firstChange\n   */\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  NgxsSimpleChange.prototype.previousValue;\n  /** @type {?} */\n\n  NgxsSimpleChange.prototype.currentValue;\n  /** @type {?} */\n\n  NgxsSimpleChange.prototype.firstChange;\n}\n/**\n * On init interface\n * @record\n */\n\n\nfunction NgxsOnInit() {}\n\nif (false) {\n  /**\n   * @param {?} ctx\n   * @return {?}\n   */\n  NgxsOnInit.prototype.ngxsOnInit = function (ctx) {};\n}\n/**\n * On change interface\n * @record\n */\n\n\nfunction NgxsOnChanges() {}\n\nif (false) {\n  /**\n   * @param {?} change\n   * @return {?}\n   */\n  NgxsOnChanges.prototype.ngxsOnChanges = function (change) {};\n}\n/**\n * After bootstrap interface\n * @record\n */\n\n\nfunction NgxsAfterBootstrap() {}\n\nif (false) {\n  /**\n   * @param {?} ctx\n   * @return {?}\n   */\n  NgxsAfterBootstrap.prototype.ngxsAfterBootstrap = function (ctx) {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass NoopNgxsExecutionStrategy {\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n  enter(func) {\n    return func();\n  }\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  leave(func) {\n    return func();\n  }\n\n}\n\nNoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n  return new (t || NoopNgxsExecutionStrategy)();\n};\n\nNoopNgxsExecutionStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NoopNgxsExecutionStrategy,\n  factory: NoopNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nNoopNgxsExecutionStrategy.ngInjectableDef = defineInjectable({\n  factory: function NoopNgxsExecutionStrategy_Factory() {\n    return new NoopNgxsExecutionStrategy();\n  },\n  token: NoopNgxsExecutionStrategy,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n * @type {?}\n */\n\n\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\n\n/** @type {?} */\n\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => {\n    /** @type {?} */\n    const injector = inject(INJECTOR);\n    /** @type {?} */\n\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n/**\n * @record\n */\n\nfunction NgxsExecutionStrategy() {}\n\nif (false) {\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n  NgxsExecutionStrategy.prototype.enter = function (func) {};\n  /**\n   * @template T\n   * @param {?} func\n   * @return {?}\n   */\n\n\n  NgxsExecutionStrategy.prototype.leave = function (func) {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n * @param {?} action\n * @return {?}\n */\n\n\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n * @param {?} action1\n * @return {?}\n */\n\n\nfunction actionMatcher(action1) {\n  /** @type {?} */\n  const type1 = getActionTypeFromInstance(action1);\n  return (\n    /**\n    * @param {?} action2\n    * @return {?}\n    */\n    function (action2) {\n      return type1 === getActionTypeFromInstance(action2);\n    }\n  );\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n * @type {?}\n */\n\n\nconst setValue =\n/**\n* @param {?} obj\n* @param {?} prop\n* @param {?} val\n* @return {?}\n*/\n(obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  /** @type {?} */\n\n  const split = prop.split('.');\n  /** @type {?} */\n\n  const lastIndex = split.length - 1;\n  split.reduce(\n  /**\n  * @param {?} acc\n  * @param {?} part\n  * @param {?} index\n  * @return {?}\n  */\n  (acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n * @type {?}\n */\n\n\nconst getValue =\n/**\n* @param {?} obj\n* @param {?} prop\n* @return {?}\n*/\n(obj, prop) => prop.split('.').reduce(\n/**\n* @param {?} acc\n* @param {?} part\n* @return {?}\n*/\n(acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n * @type {?}\n */\n\n\nconst isObject =\n/**\n* @param {?} item\n* @return {?}\n*/\nitem => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * \\@param base base object onto which `sources` will be applied\n * @type {?}\n */\n\n\nconst mergeDeep =\n/**\n* @param {?} base\n* @param {...?} sources\n* @return {?}\n*/\n(base, ...sources) => {\n  if (!sources.length) return base;\n  /** @type {?} */\n\n  const source = sources.shift();\n\n  if (isObject(base) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return mergeDeep(base, ...sources);\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T, U\n */\n\n\nfunction StateClassInternal() {}\n\nif (false) {\n  /* Skipping unnamed member:\n  [META_KEY]?: MetaDataModel;*/\n\n  /* Skipping unnamed member:\n  [META_OPTIONS_KEY]?: StoreOptions<U>;*/\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction StateOperations() {}\n\nif (false) {\n  /**\n   * @return {?}\n   */\n  StateOperations.prototype.getState = function () {};\n  /**\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  StateOperations.prototype.setState = function (val) {};\n  /**\n   * @param {?} actionOrActions\n   * @return {?}\n   */\n\n\n  StateOperations.prototype.dispatch = function (actionOrActions) {};\n}\n/**\n * @record\n */\n\n\nfunction MetaDataModel() {}\n\nif (false) {\n  /** @type {?} */\n  MetaDataModel.prototype.name;\n  /** @type {?} */\n\n  MetaDataModel.prototype.actions;\n  /** @type {?} */\n\n  MetaDataModel.prototype.defaults;\n  /** @type {?} */\n\n  MetaDataModel.prototype.path;\n  /** @type {?} */\n\n  MetaDataModel.prototype.makeRootSelector;\n  /** @type {?|undefined} */\n\n  MetaDataModel.prototype.children;\n}\n/**\n * @record\n */\n\n\nfunction RuntimeSelectorContext() {}\n\nif (false) {\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n  RuntimeSelectorContext.prototype.getStateGetter = function (key) {};\n  /**\n   * @param {?=} localOptions\n   * @return {?}\n   */\n\n\n  RuntimeSelectorContext.prototype.getSelectorOptions = function (localOptions) {};\n}\n/**\n * @record\n */\n\n\nfunction SharedSelectorOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  SharedSelectorOptions.prototype.injectContainerState;\n  /** @type {?|undefined} */\n\n  SharedSelectorOptions.prototype.suppressErrors;\n}\n/**\n * @record\n */\n\n\nfunction SelectorMetaDataModel() {}\n\nif (false) {\n  /** @type {?} */\n  SelectorMetaDataModel.prototype.makeRootSelector;\n  /** @type {?} */\n\n  SelectorMetaDataModel.prototype.originalFn;\n  /** @type {?} */\n\n  SelectorMetaDataModel.prototype.containerClass;\n  /** @type {?} */\n\n  SelectorMetaDataModel.prototype.selectorName;\n  /** @type {?} */\n\n  SelectorMetaDataModel.prototype.getSelectorOptions;\n}\n/**\n * @record\n */\n\n\nfunction MappedStore() {}\n\nif (false) {\n  /** @type {?} */\n  MappedStore.prototype.name;\n  /** @type {?} */\n\n  MappedStore.prototype.isInitialised;\n  /** @type {?} */\n\n  MappedStore.prototype.actions;\n  /** @type {?} */\n\n  MappedStore.prototype.defaults;\n  /** @type {?} */\n\n  MappedStore.prototype.instance;\n  /** @type {?} */\n\n  MappedStore.prototype.path;\n}\n/**\n * @record\n */\n\n\nfunction StatesAndDefaults() {}\n\nif (false) {\n  /** @type {?} */\n  StatesAndDefaults.prototype.defaults;\n  /** @type {?} */\n\n  StatesAndDefaults.prototype.states;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction RootStateDiff() {}\n\nif (false) {\n  /** @type {?} */\n  RootStateDiff.prototype.currentAppState;\n  /** @type {?} */\n\n  RootStateDiff.prototype.newAppState;\n}\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n * @param {?} target\n * @return {?}\n */\n\n\nfunction ensureStoreMetadata(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    /** @type {?} */\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n\n      /**\n       * @param {?} context\n       * @return {?}\n       */\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n\n  return getStoreMetadata(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n * @param {?} target\n * @return {?}\n */\n\n\nfunction getStoreMetadata(target) {\n  return (\n    /** @type {?} */\n    target[META_KEY]\n  );\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n * @param {?} target\n * @return {?}\n */\n\n\nfunction ensureSelectorMetadata(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    /** @type {?} */\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions:\n      /**\n      * @return {?}\n      */\n      () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n\n  return getSelectorMetadata(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n * @param {?} target\n * @return {?}\n */\n\n\nfunction getSelectorMetadata(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n * @param {?} paths\n * @return {?}\n */\n\n\nfunction compliantPropGetter(paths) {\n  /** @type {?} */\n  const copyOfPaths = paths.slice();\n  return (\n    /**\n    * @param {?} obj\n    * @return {?}\n    */\n    obj => copyOfPaths.reduce(\n    /**\n    * @param {?} acc\n    * @param {?} part\n    * @return {?}\n    */\n    (acc, part) => acc && acc[part], obj)\n  );\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n * @param {?} paths\n * @return {?}\n */\n\n\nfunction fastPropGetter(paths) {\n  /** @type {?} */\n  const segments = paths;\n  /** @type {?} */\n\n  let seg = 'store.' + segments[0];\n  /** @type {?} */\n\n  let i = 0;\n  /** @type {?} */\n\n  const l = segments.length;\n  /** @type {?} */\n\n  let expr = seg;\n\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  /** @type {?} */\n\n\n  const fn = new Function('store', 'return ' + expr + ';');\n  return (\n    /** @type {?} */\n    fn\n  );\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n * @param {?} paths\n * @param {?} config\n * @return {?}\n */\n\n\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n * @param {?} stateClasses\n * @return {?}\n */\n\n\nfunction buildGraph(stateClasses) {\n  /** @type {?} */\n  const findName =\n  /**\n  * @param {?} stateClass\n  * @return {?}\n  */\n  stateClass => {\n    /** @type {?} */\n    const meta = stateClasses.find(\n    /**\n    * @param {?} g\n    * @return {?}\n    */\n    g => g === stateClass); // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n\n    return (\n      /** @type {?} */\n\n      /** @type {?} */\n\n      /** @type {?} */\n      meta[META_KEY].name\n    );\n  };\n\n  return stateClasses.reduce(\n  /**\n  * @param {?} result\n  * @param {?} stateClass\n  * @return {?}\n  */\n  (result, stateClass) => {\n    const {\n      name,\n      children\n    } =\n    /** @type {?} */\n    stateClass[META_KEY];\n    result[\n    /** @type {?} */\n    name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n * @param {?} states\n * @return {?}\n */\n\n\nfunction nameToState(states) {\n  return states.reduce(\n  /**\n  * @param {?} result\n  * @param {?} stateClass\n  * @return {?}\n  */\n  (result, stateClass) => {\n    /** @type {?} */\n    const meta =\n    /** @type {?} */\n    stateClass[META_KEY];\n    result[\n    /** @type {?} */\n    meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n * @param {?} obj\n * @param {?=} newObj\n * @return {?}\n */\n\n\nfunction findFullParentPath(obj, newObj = {}) {\n  /** @type {?} */\n  const visit =\n  /**\n  * @param {?} child\n  * @param {?} keyToFind\n  * @return {?}\n  */\n  (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        /** @type {?} */\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n\n    return null;\n  };\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      /** @type {?} */\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n * @param {?} graph\n * @return {?}\n */\n\n\nfunction topologicalSort(graph) {\n  /** @type {?} */\n  const sorted = [];\n  /** @type {?} */\n\n  const visited = {};\n  /** @type {?} */\n\n  const visit =\n  /**\n  * @param {?} name\n  * @param {?=} ancestors\n  * @return {?}\n  */\n  (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(\n    /**\n    * @param {?} dep\n    * @return {?}\n    */\n    dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n\n      if (visited[dep]) {\n        return;\n      }\n\n      visit(dep, ancestors.slice(0));\n    });\n\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n\n  Object.keys(graph).forEach(\n  /**\n  * @param {?} k\n  * @return {?}\n  */\n  k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isObject$1(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n/**\n * @template T\n * @param {?} mappedStore\n * @param {?} diff\n * @return {?}\n */\n\n\nfunction getStateDiffChanges(mappedStore, diff) {\n  /** @type {?} */\n  const previousValue = getValue(diff.currentAppState, mappedStore.path);\n  /** @type {?} */\n\n  const currentValue = getValue(diff.newAppState, mappedStore.path);\n  return new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T, E\n */\n\n\nfunction ActionCompletion() {}\n\nif (false) {\n  /** @type {?} */\n  ActionCompletion.prototype.action;\n  /** @type {?} */\n\n  ActionCompletion.prototype.result;\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\"\n  /* Dispatched */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\"\n  /* Successful */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\"\n  /* Canceled */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofActionCompleted(...allowedTypes) {\n  /** @type {?} */\n  const allowedStatuses = [\"SUCCESSFUL\"\n  /* Successful */\n  , \"CANCELED\"\n  /* Canceled */\n  , \"ERRORED\"\n  /* Errored */\n  ];\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\"\n  /* Errored */\n  ]);\n}\n/**\n * @param {?} allowedTypes\n * @param {?=} statuses\n * @param {?=} mapOperator\n * @return {?}\n */\n\n\nfunction ofActionOperator(allowedTypes, statuses, // This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  /** @type {?} */\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  /** @type {?} */\n\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return (\n    /**\n    * @param {?} o\n    * @return {?}\n    */\n    function (o) {\n      return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n    }\n  );\n}\n/**\n * @param {?} allowedTypes\n * @param {?=} allowedStatuses\n * @return {?}\n */\n\n\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(\n  /**\n  * @param {?} ctx\n  * @return {?}\n  */\n  ctx => {\n    /** @type {?} */\n    const actionType =\n    /** @type {?} */\n    getActionTypeFromInstance(ctx.action);\n    /** @type {?} */\n\n    const typeMatch = allowedTypes[actionType];\n    /** @type {?} */\n\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\n/**\n * @return {?}\n */\n\n\nfunction mapActionResult() {\n  return map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    action,\n    status,\n    error\n  }) => {\n    return (\n      /** @type {?} */\n      {\n        action,\n        result: {\n          successful: \"SUCCESSFUL\"\n          /* Successful */\n          === status,\n          canceled: \"CANCELED\"\n          /* Canceled */\n          === status,\n          error\n        }\n      }\n    );\n  });\n}\n/**\n * @template T\n * @return {?}\n */\n\n\nfunction mapAction() {\n  return map(\n  /**\n  * @param {?} ctx\n  * @return {?}\n  */\n  ctx =>\n  /** @type {?} */\n  ctx.action);\n}\n/**\n * @record\n */\n\n\nfunction FilterMap() {}\n/**\n * @param {?} types\n * @return {?}\n */\n\n\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce(\n  /**\n  * @param {?} filterMap\n  * @param {?} klass\n  * @return {?}\n  */\n  (filterMap, klass) => {\n    filterMap[\n    /** @type {?} */\n    getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  },\n  /** @type {?} */\n  {});\n}\n/**\n * @param {?} statuses\n * @return {?}\n */\n\n\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce(\n  /**\n  * @param {?} filterMap\n  * @param {?} status\n  * @return {?}\n  */\n  (filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  },\n  /** @type {?} */\n  {});\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n * @template T\n * @param {?} ngxsExecutionStrategy\n * @return {?}\n */\n\n\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    source => {\n      return new Observable(\n      /**\n      * @param {?} sink\n      * @return {?}\n      */\n      sink => {\n        return source.subscribe({\n          /**\n           * @param {?} value\n           * @return {?}\n           */\n          next(value) {\n            ngxsExecutionStrategy.leave(\n            /**\n            * @return {?}\n            */\n            () => sink.next(value));\n          },\n\n          /**\n           * @param {?} error\n           * @return {?}\n           */\n          error(error) {\n            ngxsExecutionStrategy.leave(\n            /**\n            * @return {?}\n            */\n            () => sink.error(error));\n          },\n\n          /**\n           * @return {?}\n           */\n          complete() {\n            ngxsExecutionStrategy.leave(\n            /**\n            * @return {?}\n            */\n            () => sink.complete());\n          }\n\n        });\n      });\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet InternalNgxsExecutionStrategy = /*#__PURE__*/(() => {\n  class InternalNgxsExecutionStrategy {\n    /**\n     * @param {?} _executionStrategy\n     */\n    constructor(_executionStrategy) {\n      this._executionStrategy = _executionStrategy;\n    }\n    /**\n     * @template T\n     * @param {?} func\n     * @return {?}\n     */\n\n\n    enter(func) {\n      return this._executionStrategy.enter(func);\n    }\n    /**\n     * @template T\n     * @param {?} func\n     * @return {?}\n     */\n\n\n    leave(func) {\n      return this._executionStrategy.leave(func);\n    }\n\n  }\n\n  InternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n    return new (t || InternalNgxsExecutionStrategy)(ɵngcc0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n  };\n\n  InternalNgxsExecutionStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InternalNgxsExecutionStrategy,\n    factory: InternalNgxsExecutionStrategy.ɵfac\n  });\n  /** @nocollapse */\n\n  return InternalNgxsExecutionStrategy;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  InternalNgxsExecutionStrategy.prototype._executionStrategy;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {string} */\n\n\nconst ActionStatus = {\n  Dispatched: 'DISPATCHED',\n  Successful: 'SUCCESSFUL',\n  Canceled: 'CANCELED',\n  Errored: 'ERRORED'\n};\n/**\n * @record\n * @template T\n */\n\nfunction ActionContext() {}\n\nif (false) {\n  /** @type {?} */\n  ActionContext.prototype.status;\n  /** @type {?} */\n\n  ActionContext.prototype.action;\n  /** @type {?|undefined} */\n\n  ActionContext.prototype.error;\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n * subject.subscribe(value => {\n * if (value === 'start') subject.next('end');\n * });\n * subject.subscribe(value => { });\n * subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n * @template T\n */\n\n\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._itemQueue = [];\n    this._busyPushingNext = false;\n  }\n  /**\n   * @param {?=} value\n   * @return {?}\n   */\n\n\n  next(value) {\n    if (this._busyPushingNext) {\n      this._itemQueue.unshift(\n      /** @type {?} */\n      value);\n\n      return;\n    }\n\n    this._busyPushingNext = true;\n    super.next(value);\n\n    while (this._itemQueue.length > 0) {\n      /** @type {?} */\n      const nextValue = this._itemQueue.pop();\n\n      super.next(nextValue);\n    }\n\n    this._busyPushingNext = false;\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  OrderedSubject.prototype._itemQueue;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  OrderedSubject.prototype._busyPushingNext;\n}\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\n\n\nlet InternalActions = /*#__PURE__*/(() => {\n  class InternalActions extends OrderedSubject {}\n\n  InternalActions.ɵfac = /*@__PURE__*/function () {\n    let ɵInternalActions_BaseFactory;\n    return function InternalActions_Factory(t) {\n      return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n    };\n  }();\n\n  InternalActions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InternalActions,\n    factory: InternalActions.ɵfac\n  });\n  return InternalActions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\n\n\nlet Actions = /*#__PURE__*/(() => {\n  class Actions extends Observable {\n    // This has to be `Observable<ActionContext>` in the v4. Because `InternalActions`\n    // is a `Subject<ActionContext>`. Leave it as `any` to avoid breaking changes\n\n    /**\n     * @param {?} internalActions$\n     * @param {?} internalExecutionStrategy\n     */\n    constructor(internalActions$, internalExecutionStrategy) {\n      super(\n      /**\n      * @param {?} observer\n      * @return {?}\n      */\n      observer => {\n        /** @type {?} */\n        const childSubscription = internalActions$.pipe(leaveNgxs(internalExecutionStrategy)).subscribe({\n          next:\n          /**\n          * @param {?} ctx\n          * @return {?}\n          */\n          ctx => observer.next(ctx),\n          error:\n          /**\n          * @param {?} error\n          * @return {?}\n          */\n          error => observer.error(error),\n          complete:\n          /**\n          * @return {?}\n          */\n          () => observer.complete()\n        });\n        observer.add(childSubscription);\n      });\n    }\n\n  }\n\n  Actions.ɵfac = function Actions_Factory(t) {\n    return new (t || Actions)(ɵngcc0.ɵɵinject(InternalActions), ɵngcc0.ɵɵinject(InternalNgxsExecutionStrategy));\n  };\n\n  Actions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Actions,\n    factory: Actions.ɵfac\n  });\n  /** @nocollapse */\n\n  return Actions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n * @type {?}\n */\n\n\nconst compose =\n/**\n* @param {?} funcs\n* @return {?}\n*/\nfuncs =>\n/**\n* @param {...?} args\n* @return {?}\n*/\n(...args) => {\n  /** @type {?} */\n  const curr =\n  /** @type {?} */\n  funcs.shift();\n  return curr(...args,\n  /**\n  * @param {...?} nextArgs\n  * @return {?}\n  */\n  (...nextArgs) => compose(funcs)(...nextArgs));\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\n\n\nlet StateStream = /*#__PURE__*/(() => {\n  class StateStream extends BehaviorSubject {\n    constructor() {\n      super({});\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n      // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n      // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n      this.complete();\n    }\n\n  }\n\n  StateStream.ɵfac = function StateStream_Factory(t) {\n    return new (t || StateStream)();\n  };\n\n  StateStream.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: StateStream,\n    factory: StateStream.ɵfac\n  });\n  /** @nocollapse */\n\n  return StateStream;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet PluginManager = /*#__PURE__*/(() => {\n  class PluginManager {\n    /**\n     * @param {?} _parentManager\n     * @param {?} _pluginHandlers\n     */\n    constructor(_parentManager, _pluginHandlers) {\n      this._parentManager = _parentManager;\n      this._pluginHandlers = _pluginHandlers;\n      this.plugins = [];\n      this.registerHandlers();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get rootPlugins() {\n      return this._parentManager && this._parentManager.plugins || this.plugins;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    registerHandlers() {\n      /** @type {?} */\n      const pluginHandlers = this.getPluginHandlers();\n      this.rootPlugins.push(...pluginHandlers);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getPluginHandlers() {\n      /** @type {?} */\n      const handlers = this._pluginHandlers || [];\n      return handlers.map(\n      /**\n      * @param {?} plugin\n      * @return {?}\n      */\n      plugin =>\n      /** @type {?} */\n      plugin.handle ? plugin.handle.bind(plugin) : plugin);\n    }\n\n  }\n\n  PluginManager.ɵfac = function PluginManager_Factory(t) {\n    return new (t || PluginManager)(ɵngcc0.ɵɵinject(PluginManager, 12), ɵngcc0.ɵɵinject(NGXS_PLUGINS, 8));\n  };\n\n  PluginManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PluginManager,\n    factory: PluginManager.ɵfac\n  });\n  /** @nocollapse */\n\n  return PluginManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  PluginManager.prototype.plugins;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PluginManager.prototype._parentManager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PluginManager.prototype._pluginHandlers;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\n\n\nlet InternalDispatchedActionResults = /*#__PURE__*/(() => {\n  class InternalDispatchedActionResults extends Subject {}\n\n  InternalDispatchedActionResults.ɵfac = /*@__PURE__*/function () {\n    let ɵInternalDispatchedActionResults_BaseFactory;\n    return function InternalDispatchedActionResults_Factory(t) {\n      return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n    };\n  }();\n\n  InternalDispatchedActionResults.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InternalDispatchedActionResults,\n    factory: InternalDispatchedActionResults.ɵfac\n  });\n  return InternalDispatchedActionResults;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet InternalDispatcher = /*#__PURE__*/(() => {\n  class InternalDispatcher {\n    /**\n     * @param {?} _injector\n     * @param {?} _actions\n     * @param {?} _actionResults\n     * @param {?} _pluginManager\n     * @param {?} _stateStream\n     * @param {?} _ngxsExecutionStrategy\n     */\n    constructor(_injector, _actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy) {\n      this._injector = _injector;\n      this._actions = _actions;\n      this._actionResults = _actionResults;\n      this._pluginManager = _pluginManager;\n      this._stateStream = _stateStream;\n      this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n    }\n    /**\n     * Dispatches event(s).\n     * @param {?} actionOrActions\n     * @return {?}\n     */\n\n\n    dispatch(actionOrActions) {\n      /** @type {?} */\n      const result = this._ngxsExecutionStrategy.enter(\n      /**\n      * @return {?}\n      */\n      () => this.dispatchByEvents(actionOrActions));\n\n      result.subscribe({\n        error:\n        /**\n        * @param {?} error\n        * @return {?}\n        */\n        error => this._ngxsExecutionStrategy.leave(\n        /**\n        * @return {?}\n        */\n        () => {\n          try {\n            // Retrieve lazily to avoid cyclic dependency exception\n            this._errorHandler = this._errorHandler || this._injector.get(ErrorHandler);\n\n            this._errorHandler.handleError(error);\n          } catch (_a) {}\n        })\n      });\n      return result.pipe(leaveNgxs(this._ngxsExecutionStrategy));\n    }\n    /**\n     * @private\n     * @param {?} actionOrActions\n     * @return {?}\n     */\n\n\n    dispatchByEvents(actionOrActions) {\n      if (Array.isArray(actionOrActions)) {\n        if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n        return forkJoin(actionOrActions.map(\n        /**\n        * @param {?} action\n        * @return {?}\n        */\n        action => this.dispatchSingle(action)));\n      } else {\n        return this.dispatchSingle(actionOrActions);\n      }\n    }\n    /**\n     * @private\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    dispatchSingle(action) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        /** @type {?} */\n        const type = getActionTypeFromInstance(action);\n\n        if (!type) {\n          /** @type {?} */\n          const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n          return throwError(error);\n        }\n      }\n      /** @type {?} */\n\n\n      const prevState = this._stateStream.getValue();\n      /** @type {?} */\n\n\n      const plugins = this._pluginManager.plugins;\n      return (\n        /** @type {?} */\n        compose([...plugins,\n        /**\n        * @param {?} nextState\n        * @param {?} nextAction\n        * @return {?}\n        */\n        (nextState, nextAction) => {\n          if (nextState !== prevState) {\n            this._stateStream.next(nextState);\n          }\n          /** @type {?} */\n\n\n          const actionResult$ = this.getActionResultStream(nextAction);\n          actionResult$.subscribe(\n          /**\n          * @param {?} ctx\n          * @return {?}\n          */\n          ctx => this._actions.next(ctx));\n\n          this._actions.next({\n            action: nextAction,\n            status: \"DISPATCHED\"\n            /* Dispatched */\n\n          });\n\n          return this.createDispatchObservable(actionResult$);\n        }])(prevState, action).pipe(shareReplay())\n      );\n    }\n    /**\n     * @private\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    getActionResultStream(action) {\n      return this._actionResults.pipe(filter(\n      /**\n      * @param {?} ctx\n      * @return {?}\n      */\n      ctx => ctx.action === action && ctx.status !== \"DISPATCHED\"\n      /* Dispatched */\n      ), take(1), shareReplay());\n    }\n    /**\n     * @private\n     * @param {?} actionResult$\n     * @return {?}\n     */\n\n\n    createDispatchObservable(actionResult$) {\n      return actionResult$.pipe(exhaustMap(\n      /**\n      * @param {?} ctx\n      * @return {?}\n      */\n      ctx => {\n        switch (ctx.status) {\n          case \"SUCCESSFUL\"\n          /* Successful */\n          :\n            return of(this._stateStream.getValue());\n\n          case \"ERRORED\"\n          /* Errored */\n          :\n            return throwError(ctx.error);\n\n          default:\n            return EMPTY;\n        }\n      })).pipe(shareReplay());\n    }\n\n  }\n\n  InternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n    return new (t || InternalDispatcher)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(InternalActions), ɵngcc0.ɵɵinject(InternalDispatchedActionResults), ɵngcc0.ɵɵinject(PluginManager), ɵngcc0.ɵɵinject(StateStream), ɵngcc0.ɵɵinject(InternalNgxsExecutionStrategy));\n  };\n\n  InternalDispatcher.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InternalDispatcher,\n    factory: InternalDispatcher.ɵfac\n  });\n  /** @nocollapse */\n\n  return InternalDispatcher;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  InternalDispatcher.prototype._errorHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._injector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._actions;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._actionResults;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._pluginManager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._stateStream;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalDispatcher.prototype._ngxsExecutionStrategy;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n * @type {?}\n */\n\n\nconst deepFreeze =\n/**\n* @param {?} o\n* @return {?}\n*/\no => {\n  Object.freeze(o);\n  /** @type {?} */\n\n  const oIsFunction = typeof o === 'function';\n  /** @type {?} */\n\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * State Context factory class\n * @ignore\n */\n\n\nlet InternalStateOperations = /*#__PURE__*/(() => {\n  class InternalStateOperations {\n    /**\n     * @param {?} _stateStream\n     * @param {?} _dispatcher\n     * @param {?} _config\n     */\n    constructor(_stateStream, _dispatcher, _config) {\n      this._stateStream = _stateStream;\n      this._dispatcher = _dispatcher;\n      this._config = _config;\n    }\n    /**\n     * Returns the root state operators.\n     * @return {?}\n     */\n\n\n    getRootStateOperations() {\n      /** @type {?} */\n      const rootStateOperations = {\n        getState:\n        /**\n        * @return {?}\n        */\n        () => this._stateStream.getValue(),\n        setState:\n        /**\n        * @param {?} newState\n        * @return {?}\n        */\n        newState => this._stateStream.next(newState),\n        dispatch:\n        /**\n        * @param {?} actionOrActions\n        * @return {?}\n        */\n        actionOrActions => this._dispatcher.dispatch(actionOrActions)\n      };\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n      } else {\n        return rootStateOperations;\n      }\n    }\n    /**\n     * @param {?} results\n     * @return {?}\n     */\n\n\n    setStateToTheCurrentWithNew(results) {\n      /** @type {?} */\n      const stateOperations = this.getRootStateOperations(); // Get our current stream\n\n      /** @type {?} */\n\n      const currentState = stateOperations.getState(); // Set the state to the current + new\n\n      stateOperations.setState(Object.assign({}, currentState, results.defaults));\n    }\n\n  }\n\n  InternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n    return new (t || InternalStateOperations)(ɵngcc0.ɵɵinject(StateStream), ɵngcc0.ɵɵinject(InternalDispatcher), ɵngcc0.ɵɵinject(NgxsConfig));\n  };\n\n  InternalStateOperations.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InternalStateOperations,\n    factory: InternalStateOperations.ɵfac\n  });\n  /** @nocollapse */\n\n  return InternalStateOperations;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  InternalStateOperations.prototype._stateStream;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalStateOperations.prototype._dispatcher;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InternalStateOperations.prototype._config;\n}\n/**\n * @param {?} root\n * @return {?}\n */\n\n\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState:\n    /**\n    * @return {?}\n    */\n    () => root.getState(),\n    setState:\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    value => {\n      /** @type {?} */\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch:\n    /**\n    * @param {?} actions\n    * @return {?}\n    */\n    actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} val\n * @return {?}\n */\n\n\nfunction simplePatch(val) {\n  return (\n    /**\n    * @param {?} existingState\n    * @return {?}\n    */\n    existingState => {\n      if (Array.isArray(val)) {\n        throwPatchingArrayError();\n      } else if (typeof val !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n      /** @type {?} */\n\n\n      const newState = Object.assign({},\n      /** @type {?} */\n      existingState);\n\n      for (const key in val) {\n        // deep clone for patch compatibility\n        // noinspection JSUnfilteredForInLoop (IDE)\n        newState[key] =\n        /** @type {?} */\n        val[key];\n      }\n\n      return (\n        /** @type {?} */\n        newState\n      );\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * State Context factory class\n * @ignore\n */\n\n\nlet StateContextFactory = /*#__PURE__*/(() => {\n  class StateContextFactory {\n    /**\n     * @param {?} _internalStateOperations\n     */\n    constructor(_internalStateOperations) {\n      this._internalStateOperations = _internalStateOperations;\n    }\n    /**\n     * Create the state context\n     * @template T\n     * @param {?} mappedStore\n     * @return {?}\n     */\n\n\n    createStateContext(mappedStore) {\n      /** @type {?} */\n      const root = this._internalStateOperations.getRootStateOperations();\n      /**\n       * @param {?} currentAppState\n       * @return {?}\n       */\n\n\n      function getState(currentAppState) {\n        return getValue(currentAppState, mappedStore.path);\n      }\n      /**\n       * @param {?} currentAppState\n       * @param {?} newValue\n       * @return {?}\n       */\n\n\n      function setStateValue(currentAppState, newValue) {\n        /** @type {?} */\n        const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n        /** @type {?} */\n\n        const instance = mappedStore.instance;\n\n        if (instance.ngxsOnChanges) {\n          /** @type {?} */\n          const change = getStateDiffChanges(mappedStore, {\n            currentAppState,\n            newAppState\n          });\n          instance.ngxsOnChanges(change);\n        }\n\n        root.setState(newAppState);\n        return newAppState; // In doing this refactoring I noticed that there is a 'bug' where the\n        // application state is returned instead of this state slice.\n        // This has worked this way since the beginning see:\n        // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n        // This needs to be fixed, but is a 'breaking' change.\n        // I will do this fix in a subsequent PR and we can decide how to handle it.\n      }\n      /**\n       * @param {?} currentAppState\n       * @param {?} stateOperator\n       * @return {?}\n       */\n\n\n      function setStateFromOperator(currentAppState, stateOperator) {\n        /** @type {?} */\n        const local = getState(currentAppState);\n        /** @type {?} */\n\n        const newValue = stateOperator(local);\n        return setStateValue(currentAppState, newValue);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n\n      function isStateOperator(value) {\n        return typeof value === 'function';\n      }\n\n      return {\n        /**\n         * @return {?}\n         */\n        getState() {\n          /** @type {?} */\n          const currentAppState = root.getState();\n          return getState(currentAppState);\n        },\n\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        patchState(val) {\n          /** @type {?} */\n          const currentAppState = root.getState();\n          /** @type {?} */\n\n          const patchOperator = simplePatch(val);\n          return setStateFromOperator(currentAppState, patchOperator);\n        },\n\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        setState(val) {\n          /** @type {?} */\n          const currentAppState = root.getState();\n          return isStateOperator(val) ? setStateFromOperator(currentAppState, val) : setStateValue(currentAppState, val);\n        },\n\n        /**\n         * @param {?} actions\n         * @return {?}\n         */\n        dispatch(actions) {\n          return root.dispatch(actions);\n        }\n\n      };\n    }\n\n  }\n\n  StateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n    return new (t || StateContextFactory)(ɵngcc0.ɵɵinject(InternalStateOperations));\n  };\n\n  StateContextFactory.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: StateContextFactory,\n    factory: StateContextFactory.ɵfac\n  });\n  /** @nocollapse */\n\n  return StateContextFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StateContextFactory.prototype._internalStateOperations;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n */\n\n\nclass StoreValidators {\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  static checkThatStateIsNamedCorrectly(name) {\n    if (!name) {\n      throwStateNamePropertyError();\n    } else if (!this.stateNameRegex.test(name)) {\n      throwStateNameError(name);\n    }\n  }\n  /**\n   * @param {?} stateName\n   * @param {?} state\n   * @param {?} statesByName\n   * @return {?}\n   */\n\n\n  static checkThatStateNameIsUnique(stateName, state, statesByName) {\n    /** @type {?} */\n    const existingState = statesByName[stateName];\n\n    if (existingState && existingState !== state) {\n      throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n  }\n  /**\n   * @param {?} stateClasses\n   * @return {?}\n   */\n\n\n  static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n    stateClasses.forEach(\n    /**\n    * @param {?} stateClass\n    * @return {?}\n    */\n    stateClass => {\n      if (!getStoreMetadata(stateClass)) {\n        throwStateDecoratorError(stateClass.name);\n      }\n    });\n  }\n\n}\n\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreValidators.stateNameRegex;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * All provided or injected tokens must have `\\@Injectable` decorator\n * (previously, injected tokens without `\\@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n * @param {?} stateClass\n * @return {?}\n */\n\n\nfunction ensureStateClassIsInjectable(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  if (ɵivyEnabled) {\n    /** @type {?} */\n\n    /** @nocollapse */\n    const ngInjectableDef = stateClass.ɵprov;\n\n    if (!ngInjectableDef) {\n      // Don't warn if Ivy is disabled or `ɵprov` exists on the class\n      console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n    }\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * State factory class\n * @ignore\n */\n\n\nlet StateFactory = /*#__PURE__*/(() => {\n  class StateFactory {\n    /**\n     * @param {?} _injector\n     * @param {?} _config\n     * @param {?} _parentFactory\n     * @param {?} _actions\n     * @param {?} _actionResults\n     * @param {?} _stateContextFactory\n     * @param {?} _initialState\n     */\n    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n      this._injector = _injector;\n      this._config = _config;\n      this._parentFactory = _parentFactory;\n      this._actions = _actions;\n      this._actionResults = _actionResults;\n      this._stateContextFactory = _stateContextFactory;\n      this._initialState = _initialState;\n      this._actionsSubscription = null;\n      this._states = [];\n      this._statesByName = {};\n      this._statePaths = {};\n      this.getRuntimeSelectorContext = memoize(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const stateFactory = this;\n        /**\n         * @param {?} key\n         * @return {?}\n         */\n\n        function resolveGetter(key) {\n          /** @type {?} */\n          const path = stateFactory.statePaths[key];\n          return path ? propGetter(path.split('.'), stateFactory._config) : null;\n        }\n        /** @type {?} */\n\n\n        const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n          /**\n           * @param {?} key\n           * @return {?}\n           */\n          getStateGetter(key) {\n            /** @type {?} */\n            let getter = resolveGetter(key);\n\n            if (getter) {\n              return getter;\n            }\n\n            return (\n              /**\n              * @param {...?} args\n              * @return {?}\n              */\n              (...args) => {\n                // Late loaded getter\n                if (!getter) {\n                  getter = resolveGetter(key);\n                }\n\n                return getter ? getter(...args) : undefined;\n              }\n            );\n          },\n\n          /**\n           * @param {?=} localOptions\n           * @return {?}\n           */\n          getSelectorOptions(localOptions) {\n            /** @type {?} */\n            const globalSelectorOptions = stateFactory._config.selectorOptions;\n            return Object.assign({}, globalSelectorOptions, localOptions || {});\n          }\n\n        };\n        return context;\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get states() {\n      return this._parentFactory ? this._parentFactory.states : this._states;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get statesByName() {\n      return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get statePaths() {\n      return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n    }\n    /**\n     * @private\n     * @param {?} defaults\n     * @return {?}\n     */\n\n\n    static cloneDefaults(defaults) {\n      /** @type {?} */\n      let value = {};\n\n      if (Array.isArray(defaults)) {\n        value = defaults.slice();\n      } else if (isObject$1(defaults)) {\n        value = Object.assign({}, defaults);\n      } else if (defaults === undefined) {\n        value = {};\n      } else {\n        value = defaults;\n      }\n\n      return value;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      // I'm using non-null assertion here since `_actionsSubscrition` will\n      // be 100% defined. This is because `ngOnDestroy()` cannot be invoked\n      // on the `StateFactory` until its initialized :) An it's initialized\n      // for the first time along with the `NgxsRootModule`.\n\n      /** @type {?} */\n      this._actionsSubscription.unsubscribe();\n    }\n    /**\n     * Add a new state to the global defs.\n     * @param {?} stateClasses\n     * @return {?}\n     */\n\n\n    add(stateClasses) {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n      }\n\n      const {\n        newStates\n      } = this.addToStatesMap(stateClasses);\n      if (!newStates.length) return [];\n      /** @type {?} */\n\n      const stateGraph = buildGraph(newStates);\n      /** @type {?} */\n\n      const sortedStates = topologicalSort(stateGraph);\n      /** @type {?} */\n\n      const paths = findFullParentPath(stateGraph);\n      /** @type {?} */\n\n      const nameGraph = nameToState(newStates);\n      /** @type {?} */\n\n      const bootstrappedStores = [];\n\n      for (const name of sortedStates) {\n        /** @type {?} */\n        const stateClass = nameGraph[name];\n        /** @type {?} */\n\n        const path = paths[name];\n        /** @type {?} */\n\n        const meta =\n        /** @type {?} */\n        stateClass[META_KEY];\n        this.addRuntimeInfoToMeta(meta, path); // Note: previously we called `ensureStateClassIsInjectable` within the\n        // `State` decorator. This check is moved here because the `ɵprov` property\n        // will not exist on the class in JIT mode (because it's set asynchronously\n        // during JIT compilation through `Object.defineProperty`).\n\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          ensureStateClassIsInjectable(stateClass);\n        }\n        /** @type {?} */\n\n\n        const stateMap = {\n          name,\n          path,\n          isInitialised: false,\n          actions: meta.actions,\n          instance: this._injector.get(stateClass),\n          defaults: StateFactory.cloneDefaults(meta.defaults)\n        }; // ensure our store hasn't already been added\n        // but don't throw since it could be lazy\n        // loaded from different paths\n\n        if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n          bootstrappedStores.push(stateMap);\n        }\n\n        this.states.push(stateMap);\n      }\n\n      return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     * @param {?} stateClasses\n     * @return {?}\n     */\n\n\n    addAndReturnDefaults(stateClasses) {\n      /** @type {?} */\n      const classes = stateClasses || [];\n      /** @type {?} */\n\n      const mappedStores = this.add(classes);\n      /** @type {?} */\n\n      const defaults = mappedStores.reduce(\n      /**\n      * @param {?} result\n      * @param {?} mappedStore\n      * @return {?}\n      */\n      (result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n      return {\n        defaults,\n        states: mappedStores\n      };\n    }\n    /**\n     * Bind the actions to the handlers\n     * @return {?}\n     */\n\n\n    connectActionHandlers() {\n      if (this._actionsSubscription !== null) return;\n      /** @type {?} */\n\n      const dispatched$ = new Subject();\n      this._actionsSubscription = this._actions.pipe(filter(\n      /**\n      * @param {?} ctx\n      * @return {?}\n      */\n      ctx => ctx.status === \"DISPATCHED\"\n      /* Dispatched */\n      ), mergeMap(\n      /**\n      * @param {?} ctx\n      * @return {?}\n      */\n      ctx => {\n        dispatched$.next(ctx);\n        /** @type {?} */\n\n        const action = ctx.action;\n        return this.invokeActions(dispatched$,\n        /** @type {?} */\n        action).pipe(map(\n        /**\n        * @return {?}\n        */\n        () => (\n        /** @type {?} */\n        {\n          action,\n          status: \"SUCCESSFUL\"\n          /* Successful */\n\n        })), defaultIfEmpty(\n        /** @type {?} */\n        {\n          action,\n          status: \"CANCELED\"\n          /* Canceled */\n\n        }), catchError(\n        /**\n        * @param {?} error\n        * @return {?}\n        */\n        error => of(\n        /** @type {?} */\n        {\n          action,\n          status: \"ERRORED\"\n          /* Errored */\n          ,\n          error\n        })));\n      })).subscribe(\n      /**\n      * @param {?} ctx\n      * @return {?}\n      */\n      ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     * @param {?} dispatched$\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    invokeActions(dispatched$, action) {\n      /** @type {?} */\n      const type =\n      /** @type {?} */\n      getActionTypeFromInstance(action);\n      /** @type {?} */\n\n      const results = [];\n\n      for (const metadata of this.states) {\n        /** @type {?} */\n        const actionMetas = metadata.actions[type];\n\n        if (actionMetas) {\n          for (const actionMeta of actionMetas) {\n            /** @type {?} */\n            const stateContext = this._stateContextFactory.createStateContext(metadata);\n\n            try {\n              /** @type {?} */\n              let result = metadata.instance[actionMeta.fn](stateContext, action);\n\n              if (result instanceof Promise) {\n                result = from(result);\n              }\n\n              if (result instanceof Observable) {\n                // If this observable has been completed w/o emitting\n                // any value then we wouldn't want to complete the whole chain\n                // of actions. Since if any observable completes then\n                // action will be canceled.\n                // For instance if any action handler would've had such statement:\n                // `handler(ctx) { return EMPTY; }`\n                // then the action will be canceled.\n                // See https://github.com/ngxs/store/issues/1568\n                result = result.pipe(mergeMap(\n                /**\n                * @param {?} value\n                * @return {?}\n                */\n                value => {\n                  if (value instanceof Promise) {\n                    return from(value);\n                  }\n\n                  if (value instanceof Observable) {\n                    return value;\n                  }\n\n                  return of(value);\n                }), defaultIfEmpty({}));\n\n                if (actionMeta.options.cancelUncompleted) {\n                  // todo: ofActionDispatched should be used with action class\n                  result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(\n                  /** @type {?} */\n                  action))));\n                }\n              } else {\n                result = of({}).pipe(shareReplay());\n              }\n\n              results.push(result);\n            } catch (e) {\n              results.push(throwError(e));\n            }\n          }\n        }\n      }\n\n      if (!results.length) {\n        results.push(of({}));\n      }\n\n      return forkJoin(results);\n    }\n    /**\n     * @private\n     * @param {?} stateClasses\n     * @return {?}\n     */\n\n\n    addToStatesMap(stateClasses) {\n      /** @type {?} */\n      const newStates = [];\n      /** @type {?} */\n\n      const statesMap = this.statesByName;\n\n      for (const stateClass of stateClasses) {\n        /** @type {?} */\n        const stateName =\n        /** @type {?} */\n        getStoreMetadata(stateClass).name; // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n        }\n        /** @type {?} */\n\n\n        const unmountedState = !statesMap[stateName];\n\n        if (unmountedState) {\n          newStates.push(stateClass);\n          statesMap[stateName] = stateClass;\n        }\n      }\n\n      return {\n        newStates\n      };\n    }\n    /**\n     * @private\n     * @param {?} meta\n     * @param {?} path\n     * @return {?}\n     */\n\n\n    addRuntimeInfoToMeta(meta, path) {\n      this.statePaths[\n      /** @type {?} */\n      meta.name] = path; // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n      // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n      // We will need to come up with an alternative in v4 because this is used by many plugins\n\n      meta.path = path;\n    }\n    /**\n     * \\@description\n     * the method checks if the state has already been added to the tree\n     * and completed the life cycle\n     * @private\n     * @param {?} name\n     * @param {?} path\n     * @return {?}\n     */\n\n\n    hasBeenMountedAndBootstrapped(name, path) {\n      /** @type {?} */\n      const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n      return this.statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n\n  }\n\n  StateFactory.ɵfac = function StateFactory_Factory(t) {\n    return new (t || StateFactory)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(NgxsConfig), ɵngcc0.ɵɵinject(StateFactory, 12), ɵngcc0.ɵɵinject(InternalActions), ɵngcc0.ɵɵinject(InternalDispatchedActionResults), ɵngcc0.ɵɵinject(StateContextFactory), ɵngcc0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n  };\n\n  StateFactory.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: StateFactory,\n    factory: StateFactory.ɵfac\n  });\n  /** @nocollapse */\n\n  return StateFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StateFactory.prototype._actionsSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._states;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._statesByName;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._statePaths;\n  /** @type {?} */\n\n  StateFactory.prototype.getRuntimeSelectorContext;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._injector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._parentFactory;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._actions;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._actionResults;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._stateContextFactory;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StateFactory.prototype._initialState;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet LifecycleStateManager = /*#__PURE__*/(() => {\n  class LifecycleStateManager {\n    /**\n     * @param {?} internalStateOperations\n     * @param {?} stateContextFactory\n     * @param {?} bootstrapper\n     */\n    constructor(internalStateOperations, stateContextFactory, bootstrapper) {\n      this.internalStateOperations = internalStateOperations;\n      this.stateContextFactory = stateContextFactory;\n      this.bootstrapper = bootstrapper;\n    }\n    /**\n     * @template T\n     * @param {?} action\n     * @param {?} results\n     * @return {?}\n     */\n\n\n    ngxsBootstrap(action, results) {\n      this.internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(\n      /**\n      * @return {?}\n      */\n      () => !!results), tap(\n      /**\n      * @return {?}\n      */\n      () => this.invokeInit(\n      /** @type {?} */\n      results.states)), mergeMap(\n      /**\n      * @return {?}\n      */\n      () => this.bootstrapper.appBootstrapped$), filter(\n      /**\n      * @param {?} appBootstrapped\n      * @return {?}\n      */\n      appBootstrapped => !!appBootstrapped)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this.invokeBootstrap(\n      /** @type {?} */\n      results.states));\n    }\n    /**\n     * Invoke the init function on the states.\n     * @param {?} mappedStores\n     * @return {?}\n     */\n\n\n    invokeInit(mappedStores) {\n      for (const mappedStore of mappedStores) {\n        /** @type {?} */\n        const instance = mappedStore.instance;\n\n        if (instance.ngxsOnChanges) {\n          /** @type {?} */\n          const currentAppState = {};\n          /** @type {?} */\n\n          const newAppState = this.internalStateOperations.getRootStateOperations().getState();\n          /** @type {?} */\n\n          const firstDiffChange = getStateDiffChanges(mappedStore, {\n            currentAppState,\n            newAppState\n          });\n          instance.ngxsOnChanges(firstDiffChange);\n        }\n\n        if (instance.ngxsOnInit) {\n          instance.ngxsOnInit(this.getStateContext(mappedStore));\n        }\n\n        mappedStore.isInitialised = true;\n      }\n    }\n    /**\n     * Invoke the bootstrap function on the states.\n     * @param {?} mappedStores\n     * @return {?}\n     */\n\n\n    invokeBootstrap(mappedStores) {\n      for (const mappedStore of mappedStores) {\n        /** @type {?} */\n        const instance = mappedStore.instance;\n\n        if (instance.ngxsAfterBootstrap) {\n          instance.ngxsAfterBootstrap(this.getStateContext(mappedStore));\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {?} mappedStore\n     * @return {?}\n     */\n\n\n    getStateContext(mappedStore) {\n      return this.stateContextFactory.createStateContext(mappedStore);\n    }\n\n  }\n\n  LifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n    return new (t || LifecycleStateManager)(ɵngcc0.ɵɵinject(InternalStateOperations), ɵngcc0.ɵɵinject(StateContextFactory), ɵngcc0.ɵɵinject(ɵngcc1.NgxsBootstrapper));\n  };\n\n  LifecycleStateManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LifecycleStateManager,\n    factory: LifecycleStateManager.ɵfac\n  });\n  /** @nocollapse */\n\n  return LifecycleStateManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  LifecycleStateManager.prototype.internalStateOperations;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  LifecycleStateManager.prototype.stateContextFactory;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  LifecycleStateManager.prototype.bootstrapper;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\n/** @type {?} */\n\nconst selectorOptionsMetaAccessor = {\n  getOptions:\n  /**\n  * @param {?} target\n  * @return {?}\n  */\n  target => {\n    return target &&\n    /** @type {?} */\n    target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions:\n  /**\n  * @param {?} target\n  * @param {?} options\n  * @return {?}\n  */\n  (target, options) => {\n    if (!target) return;\n\n    /** @type {?} */\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\n/**\n * @record\n */\n\nfunction CreationMetadata() {}\n\nif (false) {\n  /** @type {?} */\n  CreationMetadata.prototype.containerClass;\n  /** @type {?} */\n\n  CreationMetadata.prototype.selectorName;\n  /** @type {?|undefined} */\n\n  CreationMetadata.prototype.getSelectorOptions;\n}\n/**\n * @record\n */\n\n\nfunction RuntimeSelectorInfo() {}\n\nif (false) {\n  /** @type {?} */\n  RuntimeSelectorInfo.prototype.selectorOptions;\n  /** @type {?} */\n\n  RuntimeSelectorInfo.prototype.argumentSelectorFunctions;\n}\n/**\n * Function for creating a selector\n * @template T\n * @param {?} selectors The selectors to use to create the arguments of this function\n * @param {?} originalFn The original function being made into a selector\n * @param {?=} creationMetadata\n * @return {?}\n */\n\n\nfunction createSelector(selectors, originalFn, creationMetadata) {\n  /** @type {?} */\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  /** @type {?} */\n\n  const wrappedFn =\n  /** @type {?} */\n\n  /**\n  * @param {...?} args\n  * @return {?}\n  */\n  function wrappedSelectorFn(...args) {\n    /** @type {?} */\n    const returnValue = originalFn.apply(containerClass, args);\n\n    if (returnValue instanceof Function) {\n      /** @type {?} */\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n\n    return returnValue;\n  };\n  /** @type {?} */\n\n\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  /** @type {?} */\n\n  const selectorMetaData = setupSelectorMetadata(originalFn, creationMetadata);\n  /** @type {?} */\n\n  const makeRootSelector =\n  /**\n  * @param {?} context\n  * @return {?}\n  */\n  context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return (\n      /**\n      * @param {?} rootState\n      * @return {?}\n      */\n      function selectFromRoot(rootState) {\n        // Determine arguments from the app state using the selectors\n\n        /** @type {?} */\n        const results = argumentSelectorFunctions.map(\n        /**\n        * @param {?} argFn\n        * @return {?}\n        */\n        argFn => argFn(rootState)); // if the lambda tries to access a something on the\n        // state that doesn't exist, it will throw a TypeError.\n        // since this is quite usual behaviour, we simply return undefined if so.\n\n        try {\n          return memoizedFn(...results);\n        } catch (ex) {\n          if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n            return undefined;\n          }\n\n          throw ex;\n        }\n      }\n    );\n  };\n\n  selectorMetaData.makeRootSelector = makeRootSelector;\n  return memoizedFn;\n}\n/**\n * @template T\n * @param {?} originalFn\n * @param {?} creationMetadata\n * @return {?}\n */\n\n\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  /** @type {?} */\n  const selectorMetaData = ensureSelectorMetadata(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  /** @type {?} */\n\n  let getExplicitSelectorOptions =\n  /**\n  * @return {?}\n  */\n  () => ({});\n\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  /** @type {?} */\n\n\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n\n  selectorMetaData.getSelectorOptions =\n  /**\n  * @return {?}\n  */\n  () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n\n  return selectorMetaData;\n}\n/**\n * @param {?} context\n * @param {?} selectorMetaData\n * @param {?=} selectors\n * @return {?}\n */\n\n\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  /** @type {?} */\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  /** @type {?} */\n\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  /** @type {?} */\n\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  /** @type {?} */\n\n  const argumentSelectorFunctions = selectorsToApply.map(\n  /**\n  * @param {?} selector\n  * @return {?}\n  */\n  selector => {\n    /** @type {?} */\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\n/**\n * @param {?} selectorMetaData\n * @param {?} explicitOptions\n * @return {?}\n */\n\n\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}, selectorMetaData.getSelectorOptions() || {}, explicitOptions);\n}\n/**\n * @param {?=} selectors\n * @param {?=} selectorOptions\n * @param {?=} containerClass\n * @return {?}\n */\n\n\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  /** @type {?} */\n  const selectorsToApply = [];\n  /** @type {?} */\n\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n\n    /** @type {?} */\n    const metadata = getStoreMetadata(containerClass);\n\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n * @param {?} selector\n * @return {?}\n */\n\n\nfunction getRootSelectorFactory(selector) {\n  /** @type {?} */\n  const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);\n  return metadata && metadata.makeRootSelector || (\n  /**\n  * @return {?}\n  */\n  () => selector);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet Store = /*#__PURE__*/(() => {\n  class Store {\n    /**\n     * @param {?} _stateStream\n     * @param {?} _internalStateOperations\n     * @param {?} _config\n     * @param {?} _internalExecutionStrategy\n     * @param {?} _stateFactory\n     * @param {?} initialStateValue\n     */\n    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n      this._stateStream = _stateStream;\n      this._internalStateOperations = _internalStateOperations;\n      this._config = _config;\n      this._internalExecutionStrategy = _internalExecutionStrategy;\n      this._stateFactory = _stateFactory;\n      /**\n       * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n       * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n       * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n       */\n\n      this._selectableStateStream = this._stateStream.pipe(observeOn(queueScheduler), leaveNgxs(this._internalExecutionStrategy), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n      this.initStateStream(initialStateValue);\n    }\n    /**\n     * Dispatches event(s).\n     * @param {?} actionOrActions\n     * @return {?}\n     */\n\n\n    dispatch(actionOrActions) {\n      return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n\n\n    select(selector) {\n      /** @type {?} */\n      const selectorFn = this.getStoreBoundSelectorFn(selector);\n      return this._selectableStateStream.pipe(map(selectorFn), catchError(\n      /**\n      * @param {?} err\n      * @return {?}\n      */\n      err => {\n        // if error is TypeError we swallow it to prevent usual errors with property access\n        const {\n          suppressErrors\n        } = this._config.selectorOptions;\n\n        if (err instanceof TypeError && suppressErrors) {\n          return of(undefined);\n        } // rethrow other errors\n\n\n        return throwError(err);\n      }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n\n\n    selectOnce(selector) {\n      return this.select(selector).pipe(take(1));\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n\n\n    selectSnapshot(selector) {\n      /** @type {?} */\n      const selectorFn = this.getStoreBoundSelectorFn(selector);\n      return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     * @param {?=} fn\n     * @return {?}\n     */\n\n\n    subscribe(fn) {\n      return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     * @return {?}\n     */\n\n\n    snapshot() {\n      return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     * @param {?} state\n     * @return {?}\n     */\n\n\n    reset(state) {\n      return this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    /**\n     * @private\n     * @param {?} selector\n     * @return {?}\n     */\n\n\n    getStoreBoundSelectorFn(selector) {\n      /** @type {?} */\n      const makeSelectorFn = getRootSelectorFactory(selector);\n      /** @type {?} */\n\n      const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n\n      return makeSelectorFn(runtimeContext);\n    }\n    /**\n     * @private\n     * @param {?} initialStateValue\n     * @return {?}\n     */\n\n\n    initStateStream(initialStateValue) {\n      /** @type {?} */\n      const value = this._stateStream.value;\n      /** @type {?} */\n\n      const storeIsEmpty = !value || Object.keys(value).length === 0;\n\n      if (storeIsEmpty) {\n        /** @type {?} */\n        const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n        /** @type {?} */\n\n        const storeValues = defaultStateNotEmpty ? Object.assign({}, this._config.defaultsState, initialStateValue) : initialStateValue;\n\n        this._stateStream.next(storeValues);\n      }\n    }\n\n  }\n\n  Store.ɵfac = function Store_Factory(t) {\n    return new (t || Store)(ɵngcc0.ɵɵinject(StateStream), ɵngcc0.ɵɵinject(InternalStateOperations), ɵngcc0.ɵɵinject(NgxsConfig), ɵngcc0.ɵɵinject(InternalNgxsExecutionStrategy), ɵngcc0.ɵɵinject(StateFactory), ɵngcc0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n  };\n\n  Store.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Store,\n    factory: Store.ɵfac\n  });\n  /** @nocollapse */\n\n  return Store;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n   * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n   * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n   * @type {?}\n   * @private\n   */\n  Store.prototype._selectableStateStream;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Store.prototype._stateStream;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Store.prototype._internalStateOperations;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Store.prototype._config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Store.prototype._internalExecutionStrategy;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Store.prototype._stateFactory;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `\\@Select` decorator.\n */\n\n\nlet SelectFactory = /*#__PURE__*/(() => {\n  class SelectFactory {\n    /**\n     * @param {?} store\n     * @param {?} config\n     */\n    constructor(store, config) {\n      SelectFactory.store = store;\n      SelectFactory.config = config;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      SelectFactory.store = null;\n      SelectFactory.config = null;\n    }\n\n  }\n\n  SelectFactory.ɵfac = function SelectFactory_Factory(t) {\n    return new (t || SelectFactory)(ɵngcc0.ɵɵinject(Store), ɵngcc0.ɵɵinject(NgxsConfig));\n  };\n\n  SelectFactory.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SelectFactory,\n    factory: SelectFactory.ɵfac\n  });\n  SelectFactory.store = null;\n  SelectFactory.config = null;\n  /** @nocollapse */\n\n  return SelectFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  SelectFactory.store;\n  /** @type {?} */\n\n  SelectFactory.config;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Init action\n */\n\n\nclass InitState {\n  /**\n   * @return {?}\n   */\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n\n}\n/**\n * Update action\n */\n\n\nclass UpdateState {\n  /**\n   * @param {?=} addedStates\n   */\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  UpdateState.prototype.addedStates;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Root module\n * @ignore\n */\n\n\nlet NgxsRootModule = /*#__PURE__*/(() => {\n  class NgxsRootModule {\n    /**\n     * @param {?} factory\n     * @param {?} internalStateOperations\n     * @param {?} _store\n     * @param {?} _select\n     * @param {?=} states\n     * @param {?=} lifecycleStateManager\n     */\n    constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n      // Add stores to the state graph and return their defaults\n\n      /** @type {?} */\n      const results = factory.addAndReturnDefaults(states);\n      internalStateOperations.setStateToTheCurrentWithNew(results); // Connect our actions stream\n\n      factory.connectActionHandlers(); // Dispatch the init action and invoke init and bootstrap functions after\n\n      lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n    }\n\n  }\n\n  NgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n    return new (t || NgxsRootModule)(ɵngcc0.ɵɵinject(StateFactory), ɵngcc0.ɵɵinject(InternalStateOperations), ɵngcc0.ɵɵinject(Store), ɵngcc0.ɵɵinject(SelectFactory), ɵngcc0.ɵɵinject(ROOT_STATE_TOKEN, 8), ɵngcc0.ɵɵinject(LifecycleStateManager));\n  };\n\n  NgxsRootModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxsRootModule\n  });\n  NgxsRootModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return NgxsRootModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Feature module\n * @ignore\n */\n\n\nlet NgxsFeatureModule = /*#__PURE__*/(() => {\n  class NgxsFeatureModule {\n    /**\n     * @param {?} _store\n     * @param {?} internalStateOperations\n     * @param {?} factory\n     * @param {?=} states\n     * @param {?=} lifecycleStateManager\n     */\n    constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n      // Since FEATURE_STATE_TOKEN is a multi token, we need to\n      // flatten it [[Feature1State, Feature2State], [Feature3State]]\n\n      /** @type {?} */\n      const flattenedStates = NgxsFeatureModule.flattenStates(states); // add stores to the state graph and return their defaults\n\n      /** @type {?} */\n\n      const results = factory.addAndReturnDefaults(flattenedStates);\n\n      if (results.states.length) {\n        internalStateOperations.setStateToTheCurrentWithNew(results); // dispatch the update action and invoke init and bootstrap functions after\n\n        lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n      }\n    }\n    /**\n     * @private\n     * @param {?=} states\n     * @return {?}\n     */\n\n\n    static flattenStates(states = []) {\n      return states.reduce(\n      /**\n      * @param {?} total\n      * @param {?} values\n      * @return {?}\n      */\n      (total, values) => total.concat(values), []);\n    }\n\n  }\n\n  NgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n    return new (t || NgxsFeatureModule)(ɵngcc0.ɵɵinject(Store), ɵngcc0.ɵɵinject(InternalStateOperations), ɵngcc0.ɵɵinject(StateFactory), ɵngcc0.ɵɵinject(FEATURE_STATE_TOKEN, 8), ɵngcc0.ɵɵinject(LifecycleStateManager));\n  };\n\n  NgxsFeatureModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxsFeatureModule\n  });\n  NgxsFeatureModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return NgxsFeatureModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Ngxs Module\n */\n\n\nclass NgxsModule {\n  /**\n   * Root module factory\n   * @param {?=} states\n   * @param {?=} options\n   * @return {?}\n   */\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [StateFactory, StateContextFactory, Actions, InternalActions, NgxsBootstrapper, LifecycleStateManager, InternalDispatcher, InternalDispatchedActionResults, InternalStateOperations, InternalNgxsExecutionStrategy, Store, StateStream, SelectFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n    };\n  }\n  /**\n   * Feature module factory\n   * @param {?=} states\n   * @return {?}\n   */\n\n\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [StateFactory, PluginManager, ...states, {\n        provide: FEATURE_STATE_TOKEN,\n        multi: true,\n        useValue: states\n      }]\n    };\n  }\n  /**\n   * @private\n   * @param {?} states\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  static ngxsTokenProviders(states, options) {\n    return [{\n      provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n      useValue: options.executionStrategy\n    }, {\n      provide: ROOT_STATE_TOKEN,\n      useValue: states\n    }, {\n      provide: NgxsModule.ROOT_OPTIONS,\n      useValue: options\n    }, {\n      provide: NgxsConfig,\n      useFactory: NgxsModule.ngxsConfigFactory,\n      deps: [NgxsModule.ROOT_OPTIONS]\n    }, {\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: NgxsModule.appBootstrapListenerFactory,\n      multi: true,\n      deps: [NgxsBootstrapper]\n    }, {\n      provide: INITIAL_STATE_TOKEN,\n      useFactory: NgxsModule.getInitialState\n    }, {\n      provide: NGXS_STATE_CONTEXT_FACTORY,\n      useExisting: StateContextFactory\n    }, {\n      provide: NGXS_STATE_FACTORY,\n      useExisting: StateFactory\n    }];\n  }\n  /**\n   * @private\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  static ngxsConfigFactory(options) {\n    return mergeDeep(new NgxsConfig(), options);\n  }\n  /**\n   * @private\n   * @param {?} bootstrapper\n   * @return {?}\n   */\n\n\n  static appBootstrapListenerFactory(bootstrapper) {\n    return (\n      /**\n      * @return {?}\n      */\n      () => bootstrapper.bootstrap()\n    );\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  static getInitialState() {\n    return InitialState.pop();\n  }\n\n}\n\nNgxsModule.ɵfac = function NgxsModule_Factory(t) {\n  return new (t || NgxsModule)();\n};\n\nNgxsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgxsModule\n});\nNgxsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\nNgxsModule.ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  NgxsModule.ROOT_OPTIONS;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Decorates a method with a action information.\n * @param {?} actions\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction Action(actions, options) {\n  return (\n    /**\n    * @param {?} target\n    * @param {?} name\n    * @return {?}\n    */\n    (target, name) => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        /** @type {?} */\n        const isStaticMethod = target.hasOwnProperty('prototype');\n\n        if (isStaticMethod) {\n          throwActionDecoratorError();\n        }\n      }\n      /** @type {?} */\n\n\n      const meta = ensureStoreMetadata(target.constructor);\n\n      if (!Array.isArray(actions)) {\n        actions = [actions];\n      }\n\n      for (const action of actions) {\n        /** @type {?} */\n        const type = action.type;\n\n        if (!meta.actions[type]) {\n          meta.actions[type] = [];\n        }\n\n        meta.actions[type].push({\n          fn: name,\n          options: options || {},\n          type\n        });\n      }\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\n\nfunction MutateMetaOptions() {}\n\nif (false) {\n  /** @type {?} */\n  MutateMetaOptions.prototype.meta;\n  /** @type {?} */\n\n  MutateMetaOptions.prototype.inheritedStateClass;\n  /** @type {?} */\n\n  MutateMetaOptions.prototype.optionsWithInheritance;\n}\n/**\n * Decorates a class with ngxs state information.\n * @template T\n * @param {?} options\n * @return {?}\n */\n\n\nfunction State(options) {\n  /**\n   * @param {?} inheritedStateClass\n   * @return {?}\n   */\n  function getStateOptions(inheritedStateClass) {\n    /** @type {?} */\n    const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n    return (\n      /** @type {?} */\n      Object.assign({}, inheritanceOptions, options)\n    );\n  }\n  /**\n   * @param {?} params\n   * @return {?}\n   */\n\n\n  function mutateMetaData(params) {\n    const {\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    } = params;\n    const {\n      children,\n      defaults,\n      name\n    } = optionsWithInheritance;\n    /** @type {?} */\n\n    const stateName = typeof name === 'string' ? name : name && name.getName() || null; // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n    }\n\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      /** @type {?} */\n      const inheritedMeta = inheritedStateClass[META_KEY] || {};\n      meta.actions = Object.assign({}, meta.actions, inheritedMeta.actions);\n    }\n\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n\n  return (\n    /**\n    * @param {?} target\n    * @return {?}\n    */\n    target => {\n      /** @type {?} */\n      const stateClass = target;\n      /** @type {?} */\n\n      const meta = ensureStoreMetadata(stateClass);\n      /** @type {?} */\n\n      const inheritedStateClass = Object.getPrototypeOf(stateClass);\n      /** @type {?} */\n\n      const optionsWithInheritance = getStateOptions(inheritedStateClass);\n      mutateMetaData({\n        meta,\n        inheritedStateClass,\n        optionsWithInheritance\n      });\n      stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst DOLLAR_CHAR_CODE = 36;\n/**\n * @template T\n * @param {?} selector\n * @return {?}\n */\n\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n\n  return (\n    /** @type {?} */\n    SelectFactory.store.select(selector)\n  );\n}\n/**\n * @param {?} name\n * @param {?=} rawSelector\n * @param {?=} paths\n * @return {?}\n */\n\n\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n\n  if (typeof rawSelector === 'string') {\n    /** @type {?} */\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray,\n    /** @type {?} */\n    SelectFactory.config);\n  }\n\n  return rawSelector;\n}\n/**\n * \\@example If `foo$` => make it just `foo`\n * @param {?} name\n * @return {?}\n */\n\n\nfunction removeDollarAtTheEnd(name) {\n  /** @type {?} */\n  const lastCharIndex = name.length - 1;\n  /** @type {?} */\n\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Decorator for selecting a slice of state from the store.\n * @template T\n * @param {?=} rawSelector\n * @param {...?} paths\n * @return {?}\n */\n\n\nfunction Select(rawSelector, ...paths) {\n  return (\n    /**\n    * @param {?} target\n    * @param {?} key\n    * @return {?}\n    */\n    function (target, key) {\n      /** @type {?} */\n      const name = key.toString();\n      /** @type {?} */\n\n      const selectorId = `__${name}__selector`;\n      /** @type {?} */\n\n      const selector = createSelectorFn(name, rawSelector, paths);\n      Object.defineProperties(target, {\n        [selectorId]: {\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        [name]: {\n          enumerable: true,\n          configurable: true,\n\n          /**\n           * @return {?}\n           */\n          get() {\n            return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n          }\n\n        }\n      });\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Decorator for setting selector options at a method or class level.\n * @param {?} options\n * @return {?}\n */\n\n\nfunction SelectorOptions(options) {\n  return (\n    /** @type {?} */\n\n    /**\n    * @template T\n    * @param {?} target\n    * @param {?} methodName\n    * @param {?} descriptor\n    * @return {?}\n    */\n    function decorate(target, methodName, descriptor) {\n      if (methodName) {\n        // Method Decorator\n\n        /** @type {?} */\n        const originalFn = descriptor.value ||\n        /** @type {?} */\n        descriptor.originalFn;\n\n        if (originalFn) {\n          selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n        }\n      } else {\n        // Class Decorator\n        selectorOptionsMetaAccessor.defineOptions(target, options);\n      }\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction MetaDataModel$1() {}\n\nif (false) {\n  /** @type {?} */\n  MetaDataModel$1.prototype.name;\n  /** @type {?} */\n\n  MetaDataModel$1.prototype.actions;\n  /** @type {?} */\n\n  MetaDataModel$1.prototype.defaults;\n  /** @type {?} */\n\n  MetaDataModel$1.prototype.path;\n  /** @type {?|undefined} */\n\n  MetaDataModel$1.prototype.children;\n}\n/**\n * @record\n */\n\n\nfunction SelectorMetaDataModel$1() {}\n\nif (false) {\n  /** @type {?} */\n  SelectorMetaDataModel$1.prototype.originalFn;\n  /** @type {?} */\n\n  SelectorMetaDataModel$1.prototype.containerClass;\n  /** @type {?} */\n\n  SelectorMetaDataModel$1.prototype.selectorName;\n  /** @type {?} */\n\n  SelectorMetaDataModel$1.prototype.getSelectorOptions;\n}\n/**\n * @param {?} target\n * @return {?}\n */\n\n\nfunction ensureStoreMetadata$1(target) {\n  return ensureStoreMetadata(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\n\n\nfunction getStoreMetadata$1(target) {\n  return getStoreMetadata(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\n\n\nfunction ensureSelectorMetadata$1(target) {\n  return ensureSelectorMetadata(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\n\n\nfunction getSelectorMetadata$1(target) {\n  return getSelectorMetadata(target);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Decorator for memoizing a state selector.\n * @template T\n * @param {?=} selectors\n * @return {?}\n */\n\n\nfunction Selector(selectors) {\n  return (\n    /**\n    * @template U\n    * @param {?} target\n    * @param {?} key\n    * @param {?} descriptor\n    * @return {?}\n    */\n    (target, key, descriptor) => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        /** @type {?} */\n        const isNotMethod = !(descriptor && descriptor.value !== null);\n\n        if (isNotMethod) {\n          throwSelectorDecoratorError();\n        }\n      }\n      /** @type {?} */\n\n\n      const originalFn = descriptor.value;\n      /** @type {?} */\n\n      const memoizedFn = createSelector(selectors,\n      /** @type {?} */\n      originalFn, {\n        containerClass: target,\n        selectorName: key.toString(),\n\n        /**\n         * @return {?}\n         */\n        getSelectorOptions() {\n          return {};\n        }\n\n      });\n      /** @type {?} */\n\n      const newDescriptor = {\n        configurable: true,\n\n        /**\n         * @return {?}\n         */\n        get() {\n          return memoizedFn;\n        }\n\n      }; // Add hidden property to descriptor\n\n      /** @type {?} */\n      newDescriptor['originalFn'] = originalFn;\n      return newDescriptor;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n */\n\n\nclass StateToken {\n  /**\n   * @param {?} name\n   */\n  constructor(name) {\n    this.name = name;\n    /** @type {?} */\n\n    const selectorMetadata = ensureSelectorMetadata(\n    /** @type {?} */\n    this);\n\n    selectorMetadata.makeRootSelector =\n    /**\n    * @param {?} runtimeContext\n    * @return {?}\n    */\n    runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getName() {\n    return this.name;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StateToken.prototype.name;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsModule, NgxsSimpleChange, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createSelector, ensureSelectorMetadata$1 as ensureSelectorMetadata, ensureStoreMetadata$1 as ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata$1 as getSelectorMetadata, getStoreMetadata$1 as getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, OrderedSubject as ɵa, InternalActions as ɵb, ROOT_STATE_TOKEN as ɵc, FEATURE_STATE_TOKEN as ɵd, SELECTOR_META_KEY as ɵe, NgxsConfig as ɵf, mergeDeep as ɵg, USER_PROVIDED_NGXS_EXECUTION_STRATEGY as ɵh, NGXS_EXECUTION_STRATEGY as ɵi, NgxsRootModule as ɵj, StateFactory as ɵk, InternalDispatchedActionResults as ɵl, InternalDispatcher as ɵm, StateContextFactory as ɵn, InternalStateOperations as ɵo, PluginManager as ɵp, InternalNgxsExecutionStrategy as ɵq, SelectFactory as ɵr, ensureStoreMetadata as ɵt, getStoreMetadata as ɵu, ensureSelectorMetadata as ɵv, getSelectorMetadata as ɵw, LifecycleStateManager as ɵx, NgxsFeatureModule as ɵy }; //# sourceMappingURL=ngxs-store.js.map","map":null,"metadata":{},"sourceType":"module"}